读书笔记

[toc]

# 1 入门指南

## 1.1 简介

为什么要使用 Rust？

可以让每个人编写可靠且高效的软件，让很多 bug 在编译时就能被消灭。
擅长：
- 运行速度
- 内存安全
- 多处理器

比较 C/C++，类型和内存不安全。
比较 Java/C#，保证内存安全，但性能不行。
Rust：
- 安全
- 无需GC
- 易于维护和调试。

Rust 特别擅长：
- 高性能 Web Service
- WebAssembly
- 命令行工具
- 网络编程
- 嵌入式设备
- 系统编程

Rust 用户：
- Google：Fuschia 的 Rust 代码占用 30%。
- Amazon：基于 Linux 开发的直接可以在裸机、虚拟机上运行容器的操作系统。
- System76：下一代操作系统 Redox。

Rust 优点：
- 性能
- 安全性
- 无所畏惧的并发
Rust 缺点：
- 难学。相对于 C++ 很简单……

注意：
- 学习 Rust 有很多独有概念，最好不要跳跃性的学习。

## 1.2 安装 Rust

更新 rust：rustup update
验证安装：rustc --version

本地文档 rustup doc

开发工具：IntelLij IDEA Rust 插件、VScode-rust

## 1.3 Hello World

fn main(){} ，无参数无返回值。

println! 是一个 Macro（宏）。
rust 的缩进是4个空格，不是 tab。

在Windows中会生成 .pdb 文件，包含调试信息。

Rust 是 ahead-of-time 编译的语言，可以先编译程序，把文件发给别人即可运行，无需安装 Rust。

rustc 只适合简单的 Rust 程序。大型程序应该使用 cargo。

## 1.4 cargo

cargo 是rust 的构建系统和包安装工具。

cargo new --vcs 设置版本控制工具。

cargo.toml 是 cargo 配置格式。
- [pacakge] 标题。
- [dependencies] 依赖项

Rust 中代码库叫做 crate。

如果项目没有使用 cargo，也可转换为使用 cargo。
- 移动源码到 src 下。
- 创建 Cargo.toml

编译运行
- cargo build
  - target/debug
- cargo run：构建并且运行项目。
- cargo check：检查代码，运行效率比 build 快，可以连续反复调用 check 命令。
- cargo build --release：
  - target/release


# 2 猜数游戏

## 2.1 一次猜测

## 2.2 生成神秘数字

可重现的 build
- cargo update
- cargo build

完成 guessing game 代码，在 code 目录。

# 3 数据类型

## 3.1 变量与可变性

- 变量默认不可变。
- 使用mut改变可变性。
- 常量：const
- shadowing：覆盖变量，和mut不同，可以改变变量类型。
  
## 3.2 数据类型


- 标量：代表单个值
  - 整数类型.byte:b'A'。发布情况不会溢出，而是环绕。默认 i32
  - 浮点类型，f64 默认。
  - 布尔类型
  - 字符类型：unicode大小，char 可以放入 emoji

## 3.3 数据类型：复合类型
- 复合类型
  - 元组（Tuple）：解构获取值、点标记法、
  - 数组：数组所有值类型必须相同、Vector 比数组用得多。let a:[i32; 5] 声明数组、不允许越界访问

## 3.4 函数与注释
- 函数
  - 蛇皮命名法 snake case
  - parameter 形参、argument 实参（具体值）
  - Rust 是基于表达式的语言
  - 语句没有返回值，表达式有返回值。
  - 在->符号后声明函数返回值类型。
- 注释
  - //
  - /**/

## 3.5 控制流：if else

与条件相关联的代码块叫做分支（arm）。必须使用bool类型。

当分支过多，可以考虑使用 match。

if语句可以作为表达式。

## 3.6 循环

loop、可以使用break来停止循环。

while 每次都要判断一次条件。

数据通常使用 for 来遍历，while容易出错。在 rust 中用的最多。

range可以生成某个范围内的数据（1..4）=>1, 2, 3。

# 4 所有权

## 4.1 堆内存和栈内存

所有程序在运行时都必须管理他们使用计算机内存的方式。
- Rust使用一个所有权系统来管理，让编译器在编译时检查内存问题。

stack：按值得接收顺序来存储，按相反的顺序将它们移除（LIFO），不需要分配内存，直接挨着放。

heap：需要程序员手动申请内存空间。

heap需要使用更多的消耗。

如果指令在内存中跳转的次数越少，那么速度就越快。

所有权解决的问题：
- 跟踪代码的heap空间
- 最小化heap重复数据
- 清理heap上未使用的数据避免空间不足。

**管理heap数据是所有权存在的原因。**

## 4.1.2 所有权规则

- 每个值都有一个变量，变量是所有者。
- 每个值只能有一个所有者。
- 当所有者超出作用域时，该值应该被删除。

String类型比基础标量数据类型更复杂，基础标量类型存储在栈上面。String类型存储在堆上面。

字符串字面值（"string"），也就是字符串中的值，它们不可变。

- 字符串字面值时被硬编码到最终的执行文件中的。
- String在heap上分配内存来保存编译时未知的文本内容

变量走出作用域，会调用 drop 函数。

多个变量与同一个数据使用一种独特的方式来交互，移动Move。

堆栈的变量如果 copy 给另一个变量，如果浅拷贝，容易出现double free，rust 会让前一个变量失效，避免 double free。这种做法叫做 move。

设计原则：rust 不会自动创建深拷贝。任何自动赋值的操作都是廉价的。

如果想要使用深拷贝，可以使用 clone 方法，比较消耗资源。

在栈上（基础类型）不需要 clone，直接复制即可。

Copy Trait，如果类型实现了 Copy，那么旧的变量在赋值后依然可用，和Drop有冲突。
- 任何简单标量都可以 Copy
- 任何分配内存的类型都不可以 Copy
- 常见的 Copy Trait 类型
  - u32
  - bool
  - char
  - 元组

## 4.1.3 所有权与函数

函数在返回值过程中会发生所有权的移动。

如果让函数使用某个值，但不获得所有权呢？
- 引用（Reference）

## 4.2 引用与借用

使用 & 来创建引用，这种行为叫做借用。

正常情况不可以修改借用的东西。

可以通过mut声明可变引用。
- 只能同时有一个可变引用。
- 至少有一个指针用于写入数据。
- 没有使用任何机制来同步对数据的访问。

可以通过创建多个新的作用域，来创建非同时的多个可变引用。

可变应用限制
- 不可以同时拥有一个可变引用和一个不变引用。
- 允许多个不可变引用

悬空引用（Dangling Reference）
- rust可以保证不会出现悬空引用。

引用的规则：
- 在任何时刻，只能满足下列条件之一：
  - 一个可变引用
  - 任意数量不可变的引用。
- 引用必须一直有效才行。

## 4.3 切片

不持有所有权的数据类型，切片（slice）

提取字符串中第一个单词的index，难以将index和String进行同步，但使用字符串切片就可以很容易实现。

字符串字面值是切片。let s = "hello"，s的类型其实是 &str，指向特定位置的切片。

字符串切片作为参数：
- &str作为参数类型：可以同时接收 String和&str类型。

定义函数时，使用字符串切片（&str）来代替字符串引用（&String），会使得我们的API更加的通用，而不会损失任何功能。

类似memory view

# 5 Struct

在花括号内，需要未所有字段定义名称和类型。

实例化 struct，需要为每个字段定义初始值。

一旦 Struct 的实例可变，实例中所有的字段都可变。

当字段名和字段值对应变量名相同时，可以简化。{email: email}=>{email}

struct 更新语法，如果想要基于当前 struct 示例来创建一个新的示例时，可以使用 struct 更新语法。

Tuple Struct，可以定义类似 tuple 的 struct。struct Color(i32, i32, i32);

空结构体（Unit-Like Struct），用途：在某个类型里实现某个 trait，但又不想存储数据。

struct 里面也可以存放引用，但这需要使用生命周期，生命周期保证只要struct示例有效，那么里面的引用也是有效的。

struct 里面的类型大部分时候使用 String，如果使用引用就需要设置生命周期。

## 5.2 struct例子

{:?} 输出结构体，{:#?} 输出美化后的结构体，需要对 struct 实现 debug，#[derive(debug)]

## 5.3 struct 方法

如何把方法和结构体关联呢？

impl StructName{

}

方法的参数，可以使用 &self，或者self，和其他参数一样。

方法调用的运算符，没有->运算符，但rust会自动引用或解引用。
- p1.distance(&p2)
- (&p1).distance(&p2)

上两个相等。

关联函数，不以self作为第一个参数。例如：String::from。类似于 Static 关键字。

（一个 struct 可以有多个 impl 块）

# 6 枚举与模式匹配

## 6.1 定义枚举

- IP地址：IPV4、IPv6。
  
枚举的变体都位于标识符的命名空间下。

将数据附加到枚举的变体中。
- 每个变体 可以拥有不同类型以及关联的数据量。

todo：IpAddr设计的精妙之处。

为枚举定义方法，使用impl，类似struct。


## 6.2 Option枚举

定义于标准库中，在 Preload 中，Rust 没有 Nul，使用 Option 来关联 Null 概念。

`Option<T>`和T是不同的类型。

避免 null 泛滥

## 6.3 match 控制流运算符

- 允许一个值与一系列模式进行匹配，并执行匹配模式对应的代码。
- 绑定值得匹配。Quater可以存储值。
- match必须穷举所有可能性。
  - _通配符：代替其他所有可能。


## 6.4 if let 简单的控制流

- 可以简化 match。
  - if let Some(3) = match_value。
- 更少的代码，更少的缩进
- 放弃穷举。
- 可以搭配 else。

# 7 Package、Crate、Module

## 7.1 代码组织

- 哪些暴露、哪些私有
- 模块系统
  - Package（包）：Cargo的特性。
  - Create（单元包）：一个模块数，可以产生一个 library。
  - Module（模块）：use，控制代码组织、作用域、私有路径。
  - Path：struct function、module的命名的方式。
- Package：
  - 一个 cargo.toml
  - 可能包含0-1个library crate。
  - 至少一个 crate
  - 任意数量的 binary crate。
- Crate：
  - binary
  - library
- Crate Root
  - 源文件代码
  - Rust编译器开始

- 惯例
  - src/main.rs 
    - binary crate
    - crate root
  - src/lib.rs 
    - library crate
    - crate root
  - src/bin 
    - 都是 binary crate 
- Module 控制作用域和私有性
  - 控制项目的私有性
  - 建立module
    - mod关键字
    - 可嵌套
    - 可以包含其他项定义
  
## 7.2 Path路径

- 路径形式
  - 绝对路径
  - 相对路径
- 标识符之间使用::分割。
- 私有边界
  - 默认私有
  - 父级模块无法访问子模块的私有模块
  - 子模块可以看到祖先模块的私有模块。
  - 同在级可以直接调用
- super访问父级模块的内容
- pub struct：公共结构体
  - struct字段默认私有
- 使用mod.rs控制私有和公有
- pub enum：类似 struct 
  - 公共枚举内部字段都是公有的。

## 7.3 use
- use
  - 将路径引入到作用域
  - 可以使用绝对路径，也可以使用相对路径。
  - 函数：指定到父级
  - 枚举类型：知道到枚举类型名称
    - 可以使用 as 别名
  - pub use：重新导出
- 使用外部的包
  - crago.toml
  - use引入
- 标准库 std 也被作为外部包
- use 路径相同部分::{路径不同的部分}
- 通配符 *，谨慎使用
  - 应用场景：
    - 将所有被测试的代码引入到 tests模块中。
    - 预导入模块

## 7.4 将模块内容放到其他文件

- mod module_name;
- 创建一个文件


## 8.3 String

- UTF-8编码
- 字符串是 Byte 的集合
- 字符串切片 str 或 &str。来自核心语言层面
  - 字符串字面值：存储在二进制文件中，也是字符串切片
- String 标准库
  - 可增长，可修改，可拥有。
  - UTF8
- 字符串指 String 或者 &str 
- str->String：.to_string()、String::from()、
- 修改String
  - push_str：&str
  - push()：单个字符
  - String + &str 类似fn add(&str)->String
  - &String和&str：&String会自动解引用为&str。
  - **format 宏**
- 


# 10 泛型、Trait 和生命周期

参考文章：
1. https://course.rs/basic/compound-type/string-slice.html
2. https://course.rs/difficulties/string.html
3. https://course.rs/basic/ownership/ownership.html
4. https://course.rs/basic/ownership/borrowing.html
5. https://course.rs/advance/lifetime/basic.html
6. https://course.rs/advance/lifetime/advance.html
7. https://course.rs/advance/lifetime/static.html
8. https://github.com/pretzelhammer/rust-blog/blob/master/posts/translations/zh-hans/common-rust-lifetime-misconceptions.md

在 Rust 中字符串算是一个难点。

在语言级别，Rust 只有一种字符串类型 `str`，它通常是以引用类型 `&str` 出现，也就是字符串切片。但在标准库中，还有不同类型的字符串，其中使用最广泛的是 String 类型。

当 Rust 用户提到字符串时，常常是指 `String` 类型和 `&str` 字符串切片类型，这两个类型都是 UTF-8 编码。`str` 类型是**硬编码进可执行文件，也无法修改**，但是 **String 则是一个可增长、可改变具有所有权**的 UTF-8 编码字符串。

## 10.1 提取函数消除重复代码

重复代码的危害：
- 容易出错
- 需求变更需要多处修改

消除重复代码步骤：
- 识别重复代码
- 提取重复代码到函数体中
- 将原重复代码使用函数替代。

## 10.2 泛型

泛型代码是一种模板，里面有一些**占位符**，编译器编译时会替换为具体的类型（单态化）。

占位符通常很短。

- 函数定义中使用泛型
  - 参数
  - 返回类型
- 结构体
  - 字段
- 枚举 
  - 枚举的变体具有泛型枚举类型
- 方法（结构体的方法）的定义中
  - 允许特化
  - `impl<T> Point<T>`


泛型的性能：
- 单态化：类似 TypeScript

## 10.3 Trait 

定义共享行为和共享功能。

Trait 约束。

- 定义Trait
- 在类型上实现Trait， impl xxxs for ClassName（虚函数）
  - use name::StructName
  - 需要引入 Trait 和 struct
- 实现 Trait 的约束
  - 前提条件（孤儿原则）
    - Trait或类型是本地定义的
-  默认实现
-  把Trait作为参数（作为约束）
   -  impl Trait（语法糖）
   -  Trait Bound
   -  +
   -  Where：类似 C#
-  impl限制返回类型，多种返回值时，可能会导致报错
-  `impl<T: Display + PartialOrd>`，有条件的实现Trait。
-  覆盖实现。


## 10.5 生命周期

- 生命周期概念
  - 每个引用都有生命周期，为了让引用保持有效的作用域。
  - 手动和自动标注生命周期。
- 目的：
  - 避免悬垂引用
  - 借用检查器：判断借用是否合法
- String类型、str切片类型 
- 泛型生命周期
  - 关联参数和返回值的生命周期
- 生命周期标注语法
  - 不会改变生命周期长度
  - 生命周期标注：描述多个引用的生命周期之间的关系，但是不影响生命周期。（骗编译器）
- 生命周期参数名
  - 放在引用后 &
  - 使用空格将引用和名称分开
  - &i32
  - &'a i32
  - &'a mut i32 
  - 单个生命周期标注没有意义。
- 函数签名中的生命周期标注
  - 声明在尖括号中 <'a>
  - fn longest<'a>(x: &'a str, y: &'a str) -> &'a str。返回值的生命周期为 x 和 y 的交集。
- 指定生命周期：通常取决于函数的作用
- Struct定义生命周期标注
  - 自持有
  - 引用：需要标注生命周期
- 生命周期省略规则
  - 在 Rust 引用分析中所编入的模式称为生命周期省略规则
  - 特殊情况，无需显示标注
  - 不会提供完整的推断
  - 如果不通过，需要手动标注
- 输入生命周期和输出生命周期
- 三个规则省略
  - 规则1应用于输入生命周期
  - 规则2、3用于输出生命周期 
  - 如果都不适用，报错
  - 规则1：每个引用的参数都有自己的生命周期
  - 规则2：如果只有1个输入生命周期，那么该生命周期给被赋给所有的输出生命周期参数。
  - 规则3：如果有多个生命周期，其中有一个是&self或&mut self，那么self的生命周期会被赋给输出生命周期参数（方法）。
- 静态生命周期 'static 整个程序的执行时间
  - 字符串字面值：直接存在二进制程序中。
  - 



Rust 中，有好几种 str 的表示方法。
- `String`
- `str`
- `&str`
- `&String` 
- `Box<str>`
- `Box<&str>`




参考教程：
- [Rust编程语言入门教程（Rust语言/Rust权威指南配套）](https://www.bilibili.com/video/BV1hp4y1k7SV)
- [Rust 程序设计语言 简体中文版](https://rust.bootcss.com/ch00-00-introduction.html)