
很多语言的排序算法都采用 Timesort，很值得学习。

[toc]

---

# 1 归并排序-测试样例

根据函数的实现，选取不同的测试样例。

## 1.1 无返回值

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn basic() {
        let mut res = vec![10, 8, 4, 3, 1, 9, 2, 7, 5, 6];
        merge_sort(&mut res);
        assert_eq!(res, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }

    #[test]
    fn basic_string() {
        let mut res = vec!["a", "bb", "d", "cc"];
        merge_sort(&mut res);
        assert_eq!(res, vec!["a", "bb", "cc", "d"]);
    }

    #[test]
    fn empty() {
        let mut res = Vec::<u8>::new();
        merge_sort(&mut res);
        assert_eq!(res, vec![]);
    }

    #[test]
    fn one_element() {
        let mut res = vec![1];
        merge_sort(&mut res);
        assert_eq!(res, vec![1]);
    }

    #[test]
    fn pre_sorted() {
        let mut res = vec![1, 2, 3, 4];
        merge_sort(&mut res);
        assert_eq!(res, vec![1, 2, 3, 4]);
    }

    #[test]
    fn reverse_sorted() {
        let mut res = vec![4, 3, 2, 1];
        merge_sort(&mut res);
        assert_eq!(res, vec![1, 2, 3, 4]);
    }
}
```


## 1.2 有返回值

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn basic() {
        let mut res = vec![10, 8, 4, 3, 1, 9, 2, 7, 5, 6];
        let res = merge_sort(&mut res);
        assert_eq!(res, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }

    #[test]
    fn basic_string() {
        let mut res = vec!["a", "bb", "d", "cc"];
        let res = merge_sort(&mut res);
        assert_eq!(res, vec!["a", "bb", "cc", "d"]);
    }

    #[test]
    fn empty() {
        let mut res = Vec::<i32>::new();
        let res = merge_sort(&mut res);
        assert_eq!(res, vec![]);
    }

    #[test]
    fn one_element() {
        let mut res = vec![1];
        let res = merge_sort(&mut res);
        assert_eq!(res, vec![1]);
    }

    #[test]
    fn pre_sorted() {
        let mut res = vec![1, 2, 3, 4];
        let res = merge_sort(&mut res);
        assert_eq!(res, vec![1, 2, 3, 4]);
    }

    #[test]
    fn reverse_sorted() {
        let mut res = vec![4, 3, 2, 1];
        let res = merge_sort(&mut res);
        assert_eq!(res, vec![1, 2, 3, 4]);
    }

    #[test]
    fn test_sort() {
        let mut res = vec![7, 49, 73, 58, 30, 72, 44, 78, 23, 9];
        let res = merge_sort(&mut res);
        assert_eq!(res, vec![7, 9, 23, 30, 44, 49, 58, 72, 73, 78]);
    }
}

```


# 2 归并排序-伪代码

```python
mergesort(array a)
    if (n == 1)
        return a

    arrayOne = a[0]...a[n/2]
    arrayTwo = a[n/2+1]..a[n]

    arrayOne = mergesort(arrayOne)
    arrayTwo = mergesort(arrayTwo)

    return merge(arrayOne, arrayTwo)

merge(array a, array b)
    array c

    while (a and b have elements)
        if (a[0] > b[0])
            add b[0] to the end of c
            remove b[0] from b
        else
            add a[0] to the end of c
            remove a[0] from a
    
    while (a has elements)
        add a[0] to the end of c
        remove a[0] from a
```


# 3 算法实现-最利于理解、有返回值

尽可能还原伪代码
```rust
pub fn merge_sort(arr: &mut Vec<i32>) -> Vec<i32> {
    if arr.len() == 0 || arr.len() == 1 {
        return arr.to_vec();
    }
    let mid = arr.len() / 2;

    let mut left_arr = arr[..mid].to_vec();
    let mut right_arr = arr[mid..].to_vec();
    let mut left_arr = merge_sort(&mut left_arr);
    let mut right_arr = merge_sort(&mut right_arr);

    return merge(&mut left_arr, &mut right_arr);
}

fn merge(left_arr: &mut Vec<i32>, right_arr: &mut Vec<i32>) -> Vec<i32> {
    let mut new_arr = vec![];

    while left_arr.len() > 0 && right_arr.len() > 0 {
        if left_arr[0] > right_arr[0] {
            new_arr.push(right_arr[0]);
            right_arr.remove(0);
        } else {
            new_arr.push(left_arr[0]);
            left_arr.remove(0);
        }
    }

    while left_arr.len() > 0 {
        new_arr.push(left_arr[0]);
        left_arr.remove(0);
    }

    while right_arr.len() > 0 {
        new_arr.push(right_arr[0]);
        right_arr.remove(0);
    }

    return new_arr.to_vec();
}
```

# 4 算法实现-使用泛型优化、有返回值

```rust
pub fn merge_sort<T: Copy + Ord>(arr: &mut Vec<T>) -> Vec<T> {
    if arr.len() == 0 || arr.len() == 1 {
        return arr.to_vec();
    }
    let mid = arr.len() / 2;

    let mut left_arr = arr[..mid].to_vec();
    let mut right_arr = arr[mid..].to_vec();
    let mut left_arr = merge_sort(&mut left_arr);
    let mut right_arr = merge_sort(&mut right_arr);

    return merge(&mut left_arr, &mut right_arr);
}

fn merge<T: Copy + Ord>(left_arr: &mut Vec<T>, right_arr: &mut Vec<T>) -> Vec<T> {
    let mut new_arr = vec![];

    while left_arr.len() > 0 && right_arr.len() > 0 {
        if left_arr[0] > right_arr[0] {
            new_arr.push(right_arr[0]);
            right_arr.remove(0);
        } else {
            new_arr.push(left_arr[0]);
            left_arr.remove(0);
        }
    }

    while left_arr.len() > 0 {
        new_arr.push(left_arr[0]);
        left_arr.remove(0);
    }

    while right_arr.len() > 0 {
        new_arr.push(right_arr[0]);
        right_arr.remove(0);
    }

    return new_arr.to_vec();
}
```

# 5 算法实现-传引用

```rust
// 注意区分 Vec<T> 和 [T]
pub fn merge_sort<T: Copy + Ord + Default>(arr: &mut [T]) {
    if arr.len() == 0 || arr.len() == 1 {
        return;
    }
    let mid = arr.len() / 2;

    let mut left_arr = merge_sort(&mut arr[..mid]);
    let mut right_arr = merge_sort(&mut arr[mid..]);

    return merge(arr, mid);
}

// 不能同时有两个可变引用，所以使用 arr, mid
fn merge<T: Copy + Ord + Default>(arr: &mut [T], mid: usize) {
    let mut left_arr = arr[..mid].to_vec();
    let mut right_arr = arr[mid..].to_vec();

    let (mut i, mut j) = (0, 0);
    while i < left_arr.len() && j < right_arr.len() {
        if left_arr[i] < right_arr[j] {
            // 需要实现 Default Trait
            arr[i + j] = std::mem::take(&mut left_arr[i]);
            i += 1;
        } else {
            arr[i + j] = std::mem::take(&mut right_arr[j]);
            j += 1;
        }
    }

    while i < left_arr.len() {
        arr[i + j] = std::mem::take(&mut left_arr[i]);
        i += 1;
    }

    while j < right_arr.len() {
        arr[i + j] = std::mem::take(&mut right_arr[j]);
        j += 1;
    }
}

```


# 6 算法实现-优化合并过程

非常惊艳的写法，Orz。
```rust
// 注意区分 Vec<T> 和 [T]
pub fn merge_sort<T: Copy + Ord + Default>(arr: &mut [T]) {
    // 只有当元素个数大于一时才进行排序
    if arr.len() > 1 {
        let mid = arr.len() / 2;
        // 递归排序左边数组
        let mut left_arr = merge_sort(&mut arr[..mid]);
        // 递归排序右边数组
        let mut right_arr = merge_sort(&mut arr[mid..]);
        // 合并
        return merge(arr, mid);
    }
}

// 不能同时有两个可变引用，所以使用 arr, mid
fn merge<T: Copy + Ord + Default>(arr: &mut [T], mid: usize) {
    let mut left_arr = arr[..mid].to_vec();
    let mut right_arr = arr[mid..].to_vec();
    // 数组索引
    let (mut l, mut r) = (0, 0);
    for v in arr {
        // 这里的顺序不能交换。如果交换顺序，右侧全部 push 之后，r 会超过 right_arr.len，会导致越界错误
        if r == right_arr.len() || (l < left_arr.len() && left_arr[l] < right_arr[r]) {
            *v = left_arr[l];
            l += 1;
        } else {
            *v = right_arr[r];
            r += 1;
        }
    }
}
```

# 7 归并算法小结


# 


# 效率测试与计算