> 原文链接: https://fasterthanli.me/articles/a-half-hour-to-learn-rust
> 
> 翻译：[Asura](https://github.com/asur4s)
> 
> 选题：[Asura](https://github.com/asur4s)
>
> 本文由 [Rustt](https://Rustt.org) 翻译，[StudyRust](https://studyrust.org) 荣誉推出

# 半小时快速了解 Rust

通过大量的阅读代码，能增强我们对编程语言的熟练度。但如果你不知道代码的背后含义，大量阅读又怎能获得收益呢？

在这篇文章中，不是专注于 Rust 中的一两个概念，而是尽我所能的覆盖 Rust 代码片段，并解释关键字和符号的含义。

准备好了吗？Let's go！

`let` 表示变量绑定。
```rust
let x; // 声明 x 变量
x = 42; // 将 42 赋值给 x。Rust 编译器可以自动推导此处 x 的变量类型，所以这里可以不用声明类型。
```
上面的代码也能写成一行。
```rust
let x = 42;
```
还可以通过 `:` 来显式的声明变量类型
```rust
let x: i32; // i32 表示 32 位的有符号整数
x = 42;

// 有符号整型包括：i8, i16, i32, i64, i128
// 无符号整型包括：u8, u16, u32, u64, u128 
```

如果你申明了一个变量，却没有初始化，编译器将会阻止你在初始化前使用它。

```rust
let x;
foobar(x); // error: borrow of possibly-uninitialized variable: `x`
           // 错误：借用的 x 变量可能没有初始化。 
x = 42;
```

但是，如果写成下面这样就能正常运行了
```rust
let x;
x = 42;
foobar(x); // x 变量的类型将会在这里被推断出来。
```

下划线 `_` 是一种特殊的变量，可以用于丢弃变量值，还可以用于表示任意（在 match 部分会讲到）。
```rust
// 42 是一个常量，_ 不会被赋值。
let _ = 42;

// 这里表示丢弃 get_thing 函数的任何返回结果。
let _ = get_thing();
```

以下划线为开头的变量也是被允许的，它的作用的告诉编译器，该变量即使未被使用也不要警告。
```rust
let _x = 42;
```
同一个变量名可以被多次绑定，后面的绑定会覆盖前面的绑定。
```rust
let x = 13;
let x = x + 3;
// 第二次绑定后，使用 x 变量都是指向第二个 x 变量。
// 第一个 x 变量已经不存在了。
```

Rust 中有一种数据结构叫做元组，你可以把它认为是长度固定的、可以存储不同类型值的容器。

```rust
let pair = ('a', 17);
pair.0; // 用于表示 'a'
pair.1; // 用于表示 17
```
我们可以用下面的方式来标注一个元组的数据类型

```rust
let pair: (char, i32) = ('a', 17)
```

赋值语句可以将元组进行解构，也就是，把元组中的值拆分到不同的变量中。

```rust
let (some_char, some_int) = ('a', 17);
// some_char 被赋值为 'a'，some_int 被赋值为 17
```
当函数返回元组时，利用赋值语句来解构是非常方便的。
```rust
let (left, right) = slice.split_at(middle);
```
当然，在解构元组时，也可以使用下划线 `_` 来丢弃掉某些部分。
```rust
let (_, right) = slice.split_at(middle);
```
分号 `;` 标注一条语句的结束。
```rust
let x = 3;
let y = 5;
let z = y + x;
```
这意味着一条语句可以跨越多行。
```rust
let x = vec![1, 2, 3, 4, 5, 6, 7, 8]
    .iter()
    .map(|x| x + 3)
    .fold(0, |x, y| x + y);
```
文章后续会解释上述语句的含义。关键字 `fn` 可以用于声明一个函数，下面声明一个无返回值的函数：
```rust
fn greet() {
    println!("Hi there!");
}
```
声明一个返回值类型是 i32 的函数，箭头可以用于标注返回值类型：
```rust
fn fair_dice_roll() -> i32 {
    4
}
```
一对大括号表示一个代码块，代码块有自己的作用域（后面简称“块”）。
```rust
// This prints "in", then "out"
fn main() {
    let x = "out";
    {
        // this is a different `x`
        let x = "in";
        println!("{}", x);
    }
    println!("{}", x);
}
```
块也是表达式，这意味着，块可以作为值来使用。
```rust
let x = 42;

// 和上面等价
let x = { 42 };
```
在块中，可以有多条语句。
```rust
let x = {
    let y = 1; // 第一条语句
    let z = 2; // 第二条语句
    y + z // 块末尾，即代码块的值。注意没有分号。
};
```
函数的块也满足上述的特点，因此在函数末尾可以不使用 return。使用 return 和不使用 return 是等价的：
```rust
fn fair_dice_roll() -> i32 {
    return 4;
}

fn fair_dice_roll() -> i32 {
    4
}
```
if 条件语句也是表达式：
```rust
fn fair_dice_roll() -> i32 {
    if feeling_lucky {
        6
    } else {
        4
    }
}
```
match 语句也是表达式：
```rust
fn fair_dice_roll() -> i32 {
    match feeling_lucky {
        true => 6,
        false => 4,
    }
}
```
点操作符 `.` 可以用于访问元组的值：
```rust
let a = (10, 20);
a.0; // a.0 代表 a 的下标为 0 的元素，即 10。
```
或者调用某个变量的方法：
```rust
let nick = "fasterthanlime";
nick.len(); // 值为 14
```
双分号 `::` 和点操作符 `.` 类似，不过双分号用于命名空间。在下面的例子中，`std` 是一个 crate（类似 Python 中库），`cmp` 是一个模块（类似 Python 中的一个源文件），`min` 是一个函数：
```rust
let least = std::cmp::min(3, 8); // 值为 3
```
`use` 指令可以引入其他命名空间的符号（类似 Python 中的 `import`）
```rust
use std::cmp::min;

let least = min(7, 1); // 值为 1
```
*use 指令可以和大括号一起使用*。例如，如果你想引入 `min` 和 `max` ，你可以使用下面这些方式：
```rust
// 方法 1：
use std::cmp::min;
use std::cmp::max;

// 方法 2：
use std::cmp::{min, max};

// 方法 3：
use std::{cmp::min, cmp::max};
```
使用通配符 `*` 可以引入该命名空间所有的符号。
```rust
// 将会引入 cmp 中的所有符号，包括 min、max
use std::cmp::*;
```
数据类型也是命名空间，方法可以作为常规函数使用。
```rust
let x = "amos".len(); // 值为 4
let x = str::len("amos"); // 值为 4
```
`str` 是一种基本类型，除此之外，还有许多非基础类型也被引入到作用域中。
```rust
// `Vec` 是一种常用的结构体，但不是基本类型。
let v = Vec::new();

// 同上，但是使用了 `Vec` 的全路径。
let v = std::vec::Vec::new();
```
这是因为 Rust 在所有模块的开头都插入了下面这行语句：
```rust
use std::prelude::v1::*;
```
（上面的语句将会引入了大量符号，例如 `Vec`、`String`、`Option` 和 `Result`）
```rust
struct Vec2 {
    x: f64, // 64 位浮点类型，即双精度。
    y: f64,
}
```
可以使用下面的方法来初始化结构体。
```rust
let v1 = Vec2 { x: 1.0, y: 3.0 };
let v2 = Vec2 { y: 2.0, x: 4.0 };
// 顺序不重要，重要的是名称。
```
还有一种简单的方法，可以使用其他结构体来初始化剩余的字段
```rust
let v3 = Vec2 {
    x: 14.0,
    ..v2        // 没有逗号
};
```
这叫做结构体更新语法，只能放在末尾部分，并且后面不能由逗号。

也可以更新全部字段
```rust
let v4 = Vec2 { ..v3 };
```
类似元组，结构体也可以被解构。

只需要像下面这样使用 `let` 即可
```rust
let (left, right) = slice.split_at(middle);
```
也可以像下面这样
```rust
let v = Vec2 { x: 3.0, y: 6.0 };
let Vec2 { x, y } = v;
// Vec2 中，`x` 值为 3.0, `y` 值为 `6.0`
```
还可以像下面这样
```rust
let Vec2 { x, .. } = v;
// 将会丢弃 v.y
```
`let` 句型可以作为 `if` 条件中的条件
```rust
struct Number {
    odd: bool,
    value: i32,
}

fn main() {
    let one = Number { odd: true, value: 1 };
    let two = Number { odd: false, value: 2 };
    print_number(one);
    print_number(two);
}

fn print_number(n: Number) {
    if let Number { odd: true, value } = n {
        println!("Odd number: {}", value);
    } else if let Number { odd: false, value } = n {
        println!("Even number: {}", value);
    }
}

// 输出如下：
// Odd number: 1
// Even number: 2
```
`match` 也是 rust 中的关键字，用于匹配。
```rust
fn print_number(n: Number) {
    match n {
        Number { odd: true, value } => println!("Odd number: {}", value),
        Number { odd: false, value } => println!("Even number: {}", value),
    }
}
// 输出结果和上一个例子一样。
```
`match` 匹配必须穷尽所有可能性：输入至少能匹配到一个分支
```rust
fn print_number(n: Number) {
    match n {
        Number { value: 1, .. } => println!("One"),
        Number { value: 2, .. } => println!("Two"),
        Number { value, .. } => println!("{}", value),
        // 如果不存在最后一个分支，在编译时就会报错。
    }
}
```
如果上面的写法太复杂，可以使用 `_` 来代替。`_` 可以用于匹配任意输入
```rust
fn print_number(n: Number) {
    match n.value {
        1 => println!("One"),
        2 => println!("Two"),
        _ => println!("{}", n.value),
    }
}
```
你可以为自定义类型声明方法
```rust
struct Number {
    odd: bool,
    value: i32,
}

impl Number {
    fn is_strictly_positive(self) -> bool {
        self.value > 0
    }
}
```
声明方法过后，你可以像这样使用它们
```rust
fn main() {
    let minus_two = Number {
        odd: false,
        value: -2,
    };
    println!("positive? {}", minus_two.is_strictly_positive());
// 输出：
// positive? false
}
```
变量绑定默认是不可变的，也就意味着无法修改其内部值
```rust
fn main() {
    let n = Number {
        odd: true,
        value: 17,
    };
    n.odd = false; // error: cannot assign to `n.odd`,
                   // as `n` is not declared to be mutable
                   // 译：不能给 n.dd 赋值，因为 n 没有被声明为可变。
}
```
下面这样也不能赋值
```rust
fn main() {
    let n = Number {
        odd: true,
        value: 17,
    };
    n = Number {
        odd: false,
        value: 22,
    }; // error: cannot assign twice to immutable variable `n`
}      // 译：不能给不可变变量 n 赋值两次。
``` 
`mut` 可以使变量声明为可变变量：
```rust
fn main() {
    let mut n = Number {
        odd: true,
        value: 17,
    }
    n.value = 19; // 正常运行
}
```
特质（Trait）可以同时被多种类型同时拥有：
```rust
trait Signed {
    fn is_strictly_negative(self) -> bool;
}
```
Trait 还有以下特点：
- 在任何类型上都可以实现你的 Trait。
- 在你自定义的类型上可以实现任意 Trait。
- 但不能在外部的类型上实现外部的 Trait。
> 译者注：外部是指不是由自己，而是由外部定义的，包括标准库。例如：不能在我们的代码/库里为 Vec 实现 Display trait。因为二者都是标准库，相对于你的代码而言是外部的。


以上被叫做孤儿原则。

下面在自定义的类型上实现了自己的 Trait：
```rust
impl Signed for Number {
    fn is_strictly_negative(self) -> bool {
        self.value < 0
    }
}

fn main() {
    let n = Number { odd: false, value: -44 };
    println!("{}", n.is_strictly_negative()); 
    // 输出： true
}
```
在自定义的类型上实现外部 Trait 
```rust
// 名称为 Neg 的 Trait 用于重载负号“-”。
impl std::ops::Neg for Number {
    type Output = Number;

    fn neg(self) -> Number {
        Number {
            value: -self.value,
            odd: self.odd,
        }        
    }
}

fn main() {
    let n = Number { odd: true, value: 987 };
    let m = -n; // 上面实现了 Neg 这个 Trait，所以可以在 Number 类型的变量前使用负号。
    println!("{}", m.value); // 输出：-987
}
```
`impl` 代码块总是和某种类型关联，因此，在代码块中，`Self` 指当前代码块关联的类型。
```rust
impl std::ops::Neg for Number {
    type Output = Self;

    fn neg(self) -> Self {
        Self {
            value: -self.value,
            odd: self.odd,
        }        
    }
}
```
一些 Trait 只是起标识作用，这些 Trait 不需要实现，它们只是标识这种类型可以做某些事。

例如，`i32` 实现了名为 `Copy` 的 Trait。因此，下面的代码可以正常运行
```rust
fn main() {
    let a: i32 = 15;
    let b = a; // 变量 a 被复制
    let c = a; // 变量 a 被再次复制
}
``` 
下面的代码也可以正常运行
```rust
fn print_i32(x: i32) {
    println!("x = {}", x);
}

fn main() {
    let a: i32 = 15;
    print_i32(a); // `a` is copied
    print_i32(a); // `a` is copied again
}
```
但是 `Number` 结构体却没有使用 `Copy` 进行标识，所以下面的代码会报错：
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // 变量 n 被移动到变量 m（变量 n 会被销毁）。 
    let o = n; // error: use of moved value: `n`
               // 译：错误：使用已经被移动的变量 n。
}
```
下面的代码也会报错：
```rust
fn print_number(n: Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(n); // 变量 n 被移动
    print_number(n); // error: use of moved value: `n`
                     // 译：错误：使用已经被移动的变量 n。
}
```     
如果 `print_number` 函数使用不可变引用替代上面的写法，就可以正常运行
```rust
fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(&n); // 变量 n 被借用。
    print_number(&n); // 变量 n 被再次借用。
}
```
如果 `print_number` 函数使用可变引用，并且将变量声明为可变变量，也可以正常运行
```rust
fn invert(n: &mut Number) {
    n.value = -n.value;
}

fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    // 变量 n 是可变
    let mut n = Number { odd: true, value: 51 };
    print_number(&n);
    invert(&mut n); // 可变借用
    print_number(&n);
}
```
Trait 方法也可以使用 `self` 来引用变量自身。即可以使用可变引用，也可以使用不可变引用。
```rust
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}
```
当调用 Trait 方法时，调用者会被隐式借用。
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let mut m = n.clone(); // 隐式借用
    m.value += 100;
    
    print_number(&n);
    print_number(&m);
}
``` 
值得注意的是，下面两种写法是等价的：
```rust
let m = n.clone();

let m = std::clone::Clone::clone(&n);
```
像 `Copy` 这样起标识作用的 Trait（也叫做 marker），不需要实现具体的方法。
```rust
// Note：Clone 需要实现方法。
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}

impl std::marker::Copy for Number {}
```
`Clone` 也可以像下面这样使用
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n.clone();
    let o = n.clone();
}
```
`Number` 的值将不会被移动
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // 变量 m 是变量 n 的副本，而不是把变量 n 移动到变量 m。
    let o = n; // 同上。
}
```
这些 Trait 很常用，并且可以使用 `derive` 属性来自动实现：
```rust
#[derive(Clone, Copy)]
struct Number {
    odd: bool,
    value: i32,
}

// 上面实现了 Copy 和 Clone 两个 Trait，与上面的 `impl Clone for Number`、`impl Copy for Number`的代码块效果一样。
```
函数可以声明为泛型：
```rust
fn foobar<T>(arg: T) {
    // 使用 arg 参数
}
```
函数可以有多种参数类型，而不是某种固定的类型。
```rust
fn foobar<L, R>(left: L, right: R) {
    // 使用 left 和 right 参数
}
```
泛型的参数类型可以设置约束条件。最简单的约束条件就是 Trait 名称
```rust
fn print<T: Display>(value: T) {
    println!("value = {}", value);
}

fn print<T: Debug>(value: T) {
    println!("value = {:?}", value);
}
```
也可以写成下面这样
```rust
fn print<T>(value: T)
where
    T: Display,
{
    println!("value = {}", value);
}
```
泛型的参数类型还可以更复杂：可以要求参数类型同时实现多种 Trait。
```rust
use std::fmt::Debug;

fn compare<T>(left: T, right: T)
where
    T: Debug + PartialEq,
{
    println!("{:?} {} {:?}", left, if left == right { "==" } else { "!=" }, right);
}

fn main() {
    compare("tea", "coffee");
    // 输出: "tea" != "coffee"
}
```
泛型函数可以被认为是命名空间，它包含无数具体类型的函数。

和包（crate）、模块（module）、类型（Type）一样，泛型函数可以使用 `::` 来访问某种具体类型的函数。例如：
```rust
fn main() {
    use std::any::type_name;
    println!("{}", type_name::<i32>()); // 输出：i32
    println!("{}", type_name::<(f64, char)>()); // 输出：(f64, char)
}
```
这种语法被亲切的称为 Turbofish 语法（涡轮鱼语法），因为 `::<>` 看起来像是一条鱼。

结构体也可以是泛型：
```rust
struct Pair<T> {
    a: T,
    b: T,
}

fn print_type_name<T>(_val: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let p1 = Pair { a: 3, b: 9 };
    let p2 = Pair { a: true, b: false };
    print_type_name(&p1); // 输出：Pair<i32>
    print_type_name(&p2); // 输出：Pair<bool>
}
```
标准库中的 `Vec` 也是泛型：
```rust
fn main() {
    let mut v1 = Vec::new();
    v1.push(1);
    let mut v2 = Vec::new();
    v2.push(false);
    print_type_name(&v1); // 输出：Vec<i32>
    print_type_name(&v2); // 输出：Vec<bool>
}
```
`Vec` 配备了一个宏，让我们可以在声明 `Vec` 的时候进行初始化。
```rust
fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![true, false, true];
    print_type_name(&v1); // prints "Vec<i32>"
    print_type_name(&v2); // prints "Vec<bool>"
}
```
`name!()`、`name![]`、`name!{}` 都是调用宏，宏会被展开成其它代码。

事实上，`println` 就是一个宏：
```rust
fn main() {
    println!("{}", "Hello there!");
}
```
宏展开后的代码如下所示：
```rust
fn main() {
    use std::io::{self, Write};
    io::stdout().lock().write_all(b"Hello there!\n").unwrap();
}
```
`panic` 也是一个宏，它会立即停止程序并输出错误信息：
```rust
fn main() {
    panic!("This panics");
}
// 输出: thread 'main' panicked at 'This panics', src/main.rs:3:5
// 译：线程 main 的异常位于 “This panics”，src/main. rs:3:5
```
一些函数也使用到了 `panic`。比如 `Option` 类型中的 `unwrap` 函数。

`Option` 是一种枚举类型，可以包含值，也可以为空。当 `Option` 为空时，调用 `unwrap()` 函数就会造成 `panic`。
```rust
fn main() {
    let o1: Option<i32> = Some(128);
    o1.unwrap(); // 正常执行

    let o2: Option<i32> = None;
    o2.unwrap(); // panic 异常
}
// 输出: thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21
// 译：线程 main 的异常的原因是，在值为 None 的变量上调用 `Option::unwrap()` 函数，src/libcore/option.rs:378:21
```
`Option` 不是结构体，而是枚举类型。`Option` 类型只有两种值，要么是 `Some(T)`, 要么为 `None`。
```rust
enum Option<T> {
    None,
    Some(T),
}

impl<T> Option<T> {
    fn unwrap(self) -> T {
        // 枚举变量可以用于模式匹配。
        match self {
            Self::Some(t) => t,
            Self::None => panic!(".unwrap() called on a None option"),
        }
    }
}

use self::Option::{None, Some};

fn main() {
    let o1: Option<i32> = Some(128);
    o1.unwrap(); // 正常运行

    let o2: Option<i32> = None;
    o2.unwrap(); // panic 异常
}

// 输出: thread 'main' panicked at '.unwrap() called on a None option', src/main.rs:11:27
// 译：线程 main 的异常的原因是，在值为 None 的变量上调用 `Option::unwrap()` 函数，src/main.rs:11:27
```
`Result` 也是一种枚举类型，类似 `Option`，它也只有两种值，要么是 `Ok(T)`，要么是 `Err(E)`。
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
当 `Result` 的值为 `Err(E)` 时，调用 `unwrap()` 函数也会造成 `panic`。

变量绑定是有生命周期的。
```rust
fn main() {
    // 变量 x 不存在
    {
        let x = 42; // 变量 x 存在
        println!("x = {}", x);
        // 变量 X 被销毁
    }
    // 变量 x 不存在
}
```
类似的，引用也有生命周期。
```rust
fn main() {
    // 变量 x 不存在
    {
        let x = 42; // 变量 x 存在
        let x_ref = &x; // 变量 x_ref 存在，并且借用了变量 x。
        println!("x_ref = {}", x_ref);
        // 变量 x_ref 被销毁
        // 变量 x 被销毁
    }
    // 变量 x 不存在
}
```
引用的生命周期不可以超过被借用变量的生命周期。
```rust
fn main() {
    let x_ref = {
        let x = 42;
        &x
    };
    println!("x_ref = {}", x_ref);
    // error: `x` does not live long enough
    // 译：变量 x 已经被销毁
}
```
一个变量绑定可以多次被不可变借用
```rust
fn main() {
    let x = 42;
    let x_ref1 = &x;
    let x_ref2 = &x;
    let x_ref3 = &x;
    println!("{} {} {}", x_ref1, x_ref2, x_ref3);
}
```
变量绑定被借用的时候，变量不能被修改。
```rust
fn main() {
    let mut x = 42;
    let x_ref = &x;
    x = 13;
    println!("x_ref = {}", x_ref);
    // error: cannot assign to `x` because it is borrowed
    // 译：错误：不能给变量 x 赋值，因为 x 已经被借用。
}
```
变量绑定被不可变借用的时候，不能再被可变借用。
```rust
fn main() {
    let mut x = 42;
    let x_ref1 = &x;
    let x_ref2 = &mut x;
    // error: cannot borrow `x` as mutable because it is also borrowed as immutable
    // 译：错误：不能将变量 x 作为可变借用，因为变量 x 已经被不可变借用。
    println!("x_ref1 = {}", x_ref1);
}
```
函数参数中的引用也有生命周期。
```rust
fn print(x: &i32) {
    // 变量 x 是外部变量的借用。当函数被销毁时，变量 x 也会被销毁。
}
```
一个函数可以拥有不同生命周期的引用参数，因此，函数每一个引用参数都有对应的泛型生命周期。
> 译者注：一个引用参数的函数就有一个生命周期标注: `fn foo<'a>(x: &'a i32)`，两个引用参数的有两个生命周期标注:`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`, 依此类推。

生命周期标注以单引号 `'` 开头
```rust
// 省略生命周期（没有名字的生命周期）：
fn print(x: &i32) {}

// 命名生命周期:
fn print<'a>(x: &'a i32) {}
```
函数可以返回引用，返回的引用的生命周期依赖于参数的生命周期：
```rust
struct Number {
    value: i32,
}

fn number_value<'a>(num: &'a Number) -> &'a i32 {
    &num.value
}

fn main() {
    let n = Number { value: 47 };
    let v = number_value(&n);
    // 变量 v 不可变的借用变量 n，因此变量 v 的生命周期不超过变量 n 的生命周期。
    // 当变量 v 存在时，变量 n 不能被可变的借用、不能修改，也不能被移动。
}
```
当只有一个输入生命周期，可以不命名。所有的变量都拥有同一个生命周期，因此，下面两个函数是等价的：
> 译者注：函数或者方法中，参数的生命周期被称为`输入生命周期`，返回值的生命周期被称为`输出生命周期`。
```rust
fn number_value<'a>(num: &'a Number) -> &'a i32 {
    &num.value
}

fn number_value(num: &Number) -> &i32 {
    &num.value
}
```
在结构体中，也可以使用引用，但需要给每个引用都标注上生命周期。
```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn main() {
    let x: i32 = 99;
    let x_ref = NumRef { x: &x };
    // 变量 x_ref 生命周期不能超过变量 x 的生命周期。
}
```
代码同上，但使用了函数来创建 NumRef：
```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn as_num_ref<'a>(x: &'a i32) -> NumRef<'a> {
    NumRef { x: &x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&x);
    // 变量 x_ref 生命周期不能超过变量 x 的生命周期。
}
```
代码同上，但使用了省略生命周期：
```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn as_num_ref(x: &i32) -> NumRef<'_> {
    NumRef { x: &x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&x);
   // 变量 x_ref 生命周期不能超过变量 x 的生命周期。
}
```
`impl` 块也可以使用生命周期：
```rust
impl<'a> NumRef<'a> {
    fn as_i32_ref(&'a self) -> &'a i32 {
        self.x
    }
}

fn main() {
    let x: i32 = 99;
    let x_num_ref = NumRef { x: &x };
    let x_i32_ref = x_num_ref.as_i32_ref();
    // 变量 x_num_ref 和变量 x_i32_ref 的生命周期都比变量 x 的生命周期短。
}
```
这里也可以使用省略生命周期：
```rust
impl<'a> NumRef<'a> {
    fn as_i32_ref(&self) -> &i32 {
        self.x
    }
}
```
还可以省略更多：
```rust
impl NumRef<'_> {
    fn as_i32_ref(&self) -> &i32 {
        self.x
    }
}
```
有一种特殊的生命周期，叫做`'static`，拥有该生命周期的引用可以和整个程序活得一样久。
```rust
struct Person {
    name: &'static str,
}

fn main() {
    let p = Person {
        name: "fasterthanlime",
    };
}
```
但拥有所有权的字符串不是静态的：
```rust
struct Person {
    name: &'static str,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: &name };
    // error: `name` does not live long enough
    // 译：错误：变量 name 生命周期不够长。
}
```
在上一个例子中，变量 name 不能作为静态字符串的引用（即 `&'static str`），而是一个 `String` 类型。它是被动态分配的，会被自动释放。它的生命周期是短于整个程序的生命周期。

存储一个非静态的字符串到 `Person` 中，可以考虑：

A）使用普通的生命周期
```rust
struct Person<'a> {
    name: &'a str,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: &name };
    // 变量 p 的生命周期短于变量 name 的生命周期。
}
```
B）获取字符串的所有权。


2900->3500


进阶：
1、字符串的区别（'）
2、生命周期
> PS：后面生命周期和字符串太难了，需要阅读一些文章再来翻译。


> 原文链接: https://fasterthanli.me/articles/a-half-hour-to-learn-rust
> 
> 翻译：[Asura](https://github.com/asur4s)
> 
> 选题：[Asura](https://github.com/asur4s)
>
> 本文由 [Rustt](https://Rustt.org) 翻译，[StudyRust](https://studyrust.org) 荣誉推出