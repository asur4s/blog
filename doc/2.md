> åŸæ–‡é“¾æ¥: https://fasterthanli.me/articles/a-half-hour-to-learn-rust
> 
> ç¿»è¯‘ï¼š[Asura](https://github.com/asur4s)
> 
> é€‰é¢˜ï¼š[Asura](https://github.com/asur4s)
>
> æœ¬æ–‡ç”± [Rustt](https://Rustt.org) ç¿»è¯‘ï¼Œ[StudyRust](https://studyrust.org) è£èª‰æ¨å‡º

# åŠå°æ—¶å¿«é€Ÿäº†è§£ Rust

[toc]

é€šè¿‡å¤§é‡çš„é˜…è¯»ä»£ç ï¼Œèƒ½å¢å¼ºæˆ‘ä»¬å¯¹ç¼–ç¨‹è¯­è¨€çš„ç†Ÿç»ƒåº¦ã€‚ä½†å¦‚æœä½ ä¸çŸ¥é“ä»£ç çš„èƒŒåå«ä¹‰ï¼Œå¤§é‡é˜…è¯»åˆæ€èƒ½è·å¾—æ”¶ç›Šå‘¢ï¼Ÿ

åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œä¸æ˜¯ä¸“æ³¨äº Rust ä¸­çš„ä¸€ä¸¤ä¸ªæ¦‚å¿µï¼Œè€Œæ˜¯å°½æˆ‘æ‰€èƒ½çš„è¦†ç›– Rust ä»£ç ç‰‡æ®µï¼Œå¹¶è§£é‡Šå…³é”®å­—å’Œç¬¦å·çš„å«ä¹‰ã€‚

å‡†å¤‡å¥½äº†å—ï¼ŸLet's goï¼

## 1 å˜é‡ç»‘å®š

å˜é‡ç»‘å®šçš„æ–¹æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š
```rust
let x; // å£°æ˜å˜é‡ x 
x = 42; // å°† 42 ç»‘å®šåˆ° xã€‚Rust ç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨æ¨å¯¼æ­¤å¤„ x çš„ç±»å‹ï¼Œæ‰€ä»¥è¿™é‡Œå¯ä»¥ä¸ç”¨å£°æ˜ç±»å‹ã€‚
// å˜é‡ç»‘å®šæ˜¯ä¸å¯å˜çš„ï¼ˆåœ¨ç¬¬ 9 å°èŠ‚ä¼šç»§ç»­æ¢è®¨ï¼‰
```
ä¸Šé¢çš„ä»£ç ä¹Ÿèƒ½å†™æˆä¸€è¡Œã€‚
```rust
let x = 42;
```
è¿˜å¯ä»¥é€šè¿‡ `:` æ¥æ˜¾å¼çš„æŒ‡å®šå˜é‡ç±»å‹
```rust
let x: i32; // i32 è¡¨ç¤º 32 ä½çš„æœ‰ç¬¦å·æ•´æ•°
x = 42;

// æœ‰ç¬¦å·æ•´å‹åŒ…æ‹¬ï¼ši8, i16, i32, i64, i128
// æ— ç¬¦å·æ•´å‹åŒ…æ‹¬ï¼šu8, u16, u32, u64, u128 
```
å¦‚æœä½ å£°æ˜äº†ä¸€ä¸ªå˜é‡ï¼Œå´æ²¡æœ‰åˆå§‹åŒ–ï¼Œç¼–è¯‘å™¨å°†ä¼šé˜»æ­¢ä½ åœ¨åˆå§‹åŒ–å‰ä½¿ç”¨å®ƒã€‚
```rust
let x;
foobar(x); // error: borrow of possibly-uninitialized variable: `x`
           // é”™è¯¯ï¼šå€Ÿç”¨çš„å˜é‡ x å¯èƒ½æ²¡æœ‰åˆå§‹åŒ–ã€‚ 
x = 42;
```

å†™æˆä¸‹é¢è¿™æ ·å°±èƒ½æ­£å¸¸è¿è¡Œäº†

```rust
let x;
x = 42;
foobar(x); // x å˜é‡çš„ç±»å‹å°†ä¼šåœ¨è¿™é‡Œè¢«æ¨æ–­å‡ºæ¥ã€‚
```

ä¸‹åˆ’çº¿ `_` æ˜¯ Rust ä¸­çš„ä¿ç•™æ ‡è¯†ç¬¦ã€‚ä¸åŒçš„ä¸Šä¸‹æ–‡æœ‰ä¸åŒçš„ç”¨é€”ï¼Œé€šå¸¸æ„å‘³ç€æŸäº›ä¸œè¥¿è¢«å¿½ç•¥ã€‚å¯ä»¥ç”¨äºä¸¢å¼ƒå˜é‡å€¼ï¼Œè¿˜å¯ä»¥ç”¨äºè¡¨ç¤ºä»»æ„ï¼ˆåœ¨ match éƒ¨åˆ†ä¼šè®²åˆ°ï¼‰ã€‚

```rust
// 42 æ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œ_ ä¸ä¼šè¢«èµ‹å€¼ã€‚
let _ = 42;

// è¿™é‡Œè¡¨ç¤ºä¸¢å¼ƒ get_thing å‡½æ•°çš„ä»»ä½•è¿”å›ç»“æœã€‚
let _ = get_thing();
```

å˜é‡å¯ä»¥ç”¨ä¸‹åˆ’çº¿å¼€å¤´ï¼Œå®ƒçš„ä½œç”¨çš„å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œè¯¥å˜é‡å³ä½¿æœªè¢«ä½¿ç”¨ä¹Ÿä¸è¦è­¦å‘Šã€‚

```rust
let _x = 42;
```

åŒä¸€ä¸ªå˜é‡åå¯ä»¥è¢«å¤šæ¬¡ç»‘å®šï¼Œåé¢çš„ç»‘å®šä¼šè¦†ç›–å‰é¢çš„ç»‘å®šã€‚

```rust
let x = 13;
let x = x + 3;
// ç¬¬äºŒæ¬¡ç»‘å®šåï¼Œä½¿ç”¨ x å˜é‡éƒ½æ˜¯æŒ‡å‘ç¬¬äºŒä¸ª x å˜é‡ã€‚
// ç¬¬ä¸€ä¸ª x å˜é‡å·²ç»ä¸å­˜åœ¨äº†ã€‚
```

## 2ã€å…ƒç»„

Rust ä¸­æœ‰ä¸€ç§æ•°æ®ç»“æ„å«åšå…ƒç»„ï¼Œä½ å¯ä»¥æŠŠå®ƒè®¤ä¸ºæ˜¯é•¿åº¦å›ºå®šçš„ã€å¯ä»¥å­˜å‚¨ä¸åŒç±»å‹å€¼çš„å®¹å™¨ã€‚

```rust
let pair = ('a', 17);
pair.0; // ç”¨äºè¡¨ç¤º 'a'
pair.1; // ç”¨äºè¡¨ç¤º 17
```
æŒ‡å®šå˜é‡çš„æ•°æ®ç±»å‹ä¸ºå…ƒç»„

```rust
let pair: (char, i32) = ('a', 17)
```

èµ‹å€¼è¯­å¥å¯ä»¥å°†å…ƒç»„è¿›è¡Œè§£æ„ã€‚ä¹Ÿå°±æ˜¯ï¼ŒæŠŠå…ƒç»„ä¸­çš„å€¼æ‹†åˆ†åˆ°ä¸åŒçš„å˜é‡ä¸­ã€‚

```rust
let (some_char, some_int) = ('a', 17);
// some_char è¢«èµ‹å€¼ä¸º 'a'ï¼Œsome_int è¢«èµ‹å€¼ä¸º 17
```

å½“å‡½æ•°è¿”å›å…ƒç»„æ—¶ï¼Œåˆ©ç”¨èµ‹å€¼è¯­å¥æ¥è§£æ„æ˜¯éå¸¸æ–¹ä¾¿çš„ã€‚

```rust
let (left, right) = slice.split_at(middle);
```

å½“ç„¶ï¼Œåœ¨è§£æ„å…ƒç»„æ—¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸‹åˆ’çº¿ `_` æ¥ä¸¢å¼ƒæ‰æŸäº›éƒ¨åˆ†ã€‚

```rust
let (_, right) = slice.split_at(middle);
```

## 3ã€è¯­å¥

åˆ†å· `;` æ ‡æ³¨ä¸€æ¡è¯­å¥çš„ç»“æŸã€‚
```rust
let x = 3;
let y = 5;
let z = y + x;
```

è¿™æ„å‘³ç€ä¸€æ¡è¯­å¥å¯ä»¥è·¨è¶Šå¤šè¡Œã€‚

```rust
let x = vec![1, 2, 3, 4, 5, 6, 7, 8]
    .iter()
    .map(|x| x + 3)
    .fold(0, |x, y| x + y);
```

æ–‡ç« åç»­ä¼šè§£é‡Šä¸Šè¿°è¯­å¥çš„å«ä¹‰ã€‚

## 4ã€å‡½æ•°ä¸ä»£ç å—

å…³é”®å­— `fn` å¯ä»¥ç”¨äºå£°æ˜ä¸€ä¸ªå‡½æ•°ï¼Œä¸‹é¢å£°æ˜ä¸€ä¸ªæ— è¿”å›å€¼çš„å‡½æ•°ï¼š

```rust
fn greet() {
    println!("Hi there!");
}
```

å£°æ˜ä¸€ä¸ªè¿”å›å€¼ç±»å‹æ˜¯ i32 çš„å‡½æ•°ï¼Œç®­å¤´å¯ä»¥ç”¨äºæ ‡æ³¨è¿”å›å€¼ç±»å‹ï¼š

```rust
fn fair_dice_roll() -> i32 {
    4
}
```

å¤§æ‹¬å·è¡¨ç¤ºä»£ç å—ï¼Œä»£ç å—æœ‰è‡ªå·±çš„ä½œç”¨åŸŸï¼ˆåé¢ç®€ç§°â€œå—â€ï¼‰ã€‚
```rust
fn main() {
    let x = "out";
    {
        // å¦ä¸€ä¸ª x å˜é‡
        let x = "in";
        println!("{}", x);
    }
    println!("{}", x);
}
// è¾“å‡ºï¼š
// in
// out
```

å—ä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼Œè¿™æ„å‘³ç€ï¼Œå—å¯ä»¥ä½œä¸ºå€¼æ¥ä½¿ç”¨ã€‚
```rust
let x = 42;

// å’Œä¸Šé¢ç­‰ä»·
let x = { 42 };
```

åœ¨å—ä¸­ï¼Œå¯ä»¥æœ‰å¤šæ¡è¯­å¥ã€‚
```rust
let x = {
    let y = 1; // ç¬¬ä¸€æ¡è¯­å¥
    let z = 2; // ç¬¬äºŒæ¡è¯­å¥
    y + z // å—æœ«å°¾ï¼Œå³ä»£ç å—çš„å€¼ã€‚æ³¨æ„æ²¡æœ‰åˆ†å·ã€‚
};
```

å‡½æ•°çš„å—ä¹Ÿæ»¡è¶³ä¸Šè¿°çš„ç‰¹ç‚¹ï¼Œå› æ­¤åœ¨å‡½æ•°æœ«å°¾å¯ä»¥ä¸ä½¿ç”¨ returnã€‚ä½¿ç”¨ return å’Œä¸ä½¿ç”¨ return æ˜¯ç­‰ä»·çš„ï¼š
```rust
fn fair_dice_roll() -> i32 {
    return 4;
}

fn fair_dice_roll() -> i32 {
    4
}
```

if æ¡ä»¶è¯­å¥ä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼š
```rust
fn fair_dice_roll() -> i32 {
    if feeling_lucky {
        6
    } else {
        4
    }
}
```

match è¯­å¥ä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼š
```rust
fn fair_dice_roll() -> i32 {
    match feeling_lucky {
        true => 6,
        false => 4,
    }
}

```

## 5ã€æ ‡è¯†ç¬¦ä¸å‘½åç©ºé—´

ç‚¹æ“ä½œç¬¦ `.` å¯ä»¥ç”¨äºè®¿é—®å…ƒç»„çš„å€¼ï¼š
```rust
let a = (10, 20);
a.0; // a.0 ä»£è¡¨ a çš„ä¸‹æ ‡ä¸º 0 çš„å…ƒç´ ï¼Œå³ 10ã€‚
```

ç‚¹æ“ä½œç¬¦è¿˜å¯ä»¥è°ƒç”¨æŸä¸ªå˜é‡çš„æ–¹æ³•ï¼š
```rust
let nick = "fasterthanlime";
nick.len(); // å€¼ä¸º 14
```

åŒåˆ†å· `::` å’Œç‚¹æ“ä½œç¬¦ `.` ç±»ä¼¼ï¼Œä¸è¿‡åŒåˆ†å·ç”¨äºå‘½åç©ºé—´ã€‚åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œ`std` æ˜¯ä¸€ä¸ª crateï¼ˆç±»ä¼¼ Python ä¸­åº“ï¼‰ï¼Œ`cmp` æ˜¯åº“é‡Œé¢ä¸€ä¸ªæ¨¡å—ï¼ˆç±»ä¼¼ Python ä¸­çš„ä¸€ä¸ªæºæ–‡ä»¶ï¼‰ï¼Œ`min` æ˜¯æ¨¡å—ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼š
```rust
let least = std::cmp::min(3, 8); // å€¼ä¸º 3
```

`use` æŒ‡ä»¤å¯ä»¥å¼•å…¥å…¶ä»–å‘½åç©ºé—´çš„ç¬¦å·ï¼ˆç±»ä¼¼ Python ä¸­çš„ `import`ï¼‰
```rust
use std::cmp::min;

let least = min(7, 1); // å€¼ä¸º 1
```

`use` æŒ‡ä»¤å¯ä»¥å’Œå¤§æ‹¬å·ä¸€èµ·ä½¿ç”¨ã€‚å¦‚æœä½ æƒ³å¼•å…¥ `min` å’Œ `max` ï¼Œä½ å¯ä»¥ä½¿ç”¨ä¸‹é¢è¿™äº›æ–¹å¼ï¼š
```rust
// æ–¹æ³• 1ï¼š
use std::cmp::min;
use std::cmp::max;

// æ–¹æ³• 2ï¼š
use std::cmp::{min, max};

// æ–¹æ³• 3ï¼š
use std::{cmp::min, cmp::max};
```

ä½¿ç”¨é€šé…ç¬¦ `*` å¯ä»¥å¼•å…¥è¯¥å‘½åç©ºé—´æ‰€æœ‰çš„ç¬¦å·ã€‚
```rust
// å°†ä¼šå¼•å…¥ cmp ä¸­çš„æ‰€æœ‰ç¬¦å·ï¼ŒåŒ…æ‹¬ minã€max
use std::cmp::*;
```

æ•°æ®ç±»å‹ä¹Ÿæ˜¯ä¸€ç§å‘½åç©ºé—´ï¼Œæ–¹æ³•å¯ä»¥ä½œä¸ºå¸¸è§„å‡½æ•°ä½¿ç”¨ã€‚
```rust
let x = "amos".len(); // å€¼ä¸º 4
let x = str::len("amos"); // å€¼ä¸º 4
```

`str` æ˜¯ä¸€ç§åŸºæœ¬ç±»å‹ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰è®¸å¤šéåŸºç¡€ç±»å‹ä¹Ÿè¢«å¼•å…¥åˆ°ä½œç”¨åŸŸä¸­ã€‚
```rust
// `Vec` æ˜¯ä¸€ç§å¸¸ç”¨çš„ç»“æ„ä½“ï¼Œä½†ä¸æ˜¯åŸºæœ¬ç±»å‹ã€‚
let v = Vec::new();

// åŒä¸Šï¼Œä½†æ˜¯ä½¿ç”¨äº† `Vec` çš„å…¨è·¯å¾„ã€‚
let v = std::vec::Vec::new();
```

è¿™æ˜¯å› ä¸º Rust åœ¨æ‰€æœ‰æ¨¡å—çš„å¼€å¤´éƒ½æ’å…¥äº†ä¸‹é¢è¿™è¡Œè¯­å¥ï¼š
```rust
use std::prelude::v1::*;
```
ï¼ˆä¸Šé¢çš„è¯­å¥å°†ä¼šå¼•å…¥äº†å¤§é‡ç¬¦å·ï¼Œä¾‹å¦‚ `Vec`ã€`String`ã€`Option` å’Œ `Result`ï¼‰

## 6ã€ç»“æ„ä½“

ç±»ä¼¼ C å’Œ C++ï¼ŒRust ä¸­ä¹Ÿæœ‰ç»“æ„ä½“ï¼š
```rust
struct Vec2 {
    x: f64, // 64 ä½æµ®ç‚¹ç±»å‹ï¼Œå³åŒç²¾åº¦ã€‚
    y: f64,
}
```
ä½¿ç”¨ä¸‹é¢çš„æ–¹æ³•æ¥åˆå§‹åŒ–ç»“æ„ä½“ã€‚
```rust
let v1 = Vec2 { x: 1.0, y: 3.0 };
let v2 = Vec2 { y: 2.0, x: 4.0 };
// é¡ºåºä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯åç§°ã€‚
```
è¿˜æœ‰ä¸€ç§ç®€å•çš„æ–¹æ³•â€”â€”ä½¿ç”¨å…¶ä»–ç»“æ„ä½“æ¥åˆå§‹åŒ–å‰©ä½™çš„å­—æ®µ
```rust
let v3 = Vec2 {
    x: 14.0,
    ..v2        // æ²¡æœ‰é€—å·
};
```
è¿™ç§æ–¹æ³•å«åšç»“æ„ä½“æ›´æ–°è¯­æ³•ï¼Œåªèƒ½æ”¾åœ¨æœ«å°¾éƒ¨åˆ†ï¼Œå¹¶ä¸”åé¢ä¸èƒ½ç”±é€—å·ã€‚

ç»“æ„ä½“æ›´æ–°è¯­æ³•å¯ä»¥æ›´æ–°å…¨éƒ¨å­—æ®µï¼š
```rust
let v4 = Vec2 { ..v3 };
```

ç±»ä¼¼å…ƒç»„ï¼Œç»“æ„ä½“ä¹Ÿå¯ä»¥è¢«è§£æ„ã€‚åªéœ€è¦åƒä¸‹é¢è¿™æ ·ä½¿ç”¨ `let` å³å¯
```rust
let (left, right) = slice.split_at(middle);
```

ä¹Ÿå¯ä»¥åƒä¸‹é¢è¿™æ ·
```rust
let v = Vec2 { x: 3.0, y: 6.0 };
let Vec2 { x, y } = v;
// Vec2 ä¸­ï¼Œx å€¼ä¸º 3.0, y å€¼ä¸º 6.0
```

è¿˜å¯ä»¥åƒä¸‹é¢è¿™æ ·
```rust
let Vec2 { x, .. } = v;
// å°†ä¼šä¸¢å¼ƒ v.y
```

## 7ã€let ä¸ match

`let` å¥å‹å¯ä»¥ä½œä¸º `if` æ¡ä»¶ä¸­çš„æ¡ä»¶
```rust
struct Number {
    odd: bool,
    value: i32,
}

fn main() {
    let one = Number { odd: true, value: 1 };
    let two = Number { odd: false, value: 2 };
    print_number(one);
    print_number(two);
}

fn print_number(n: Number) {
    if let Number { odd: true, value } = n {
        println!("Odd number: {}", value);
    } else if let Number { odd: false, value } = n {
        println!("Even number: {}", value);
    }
}

// è¾“å‡ºå¦‚ä¸‹ï¼š
// Odd number: 1
// Even number: 2
```

`match` ä¹Ÿæ˜¯ rust ä¸­çš„å…³é”®å­—ï¼Œç”¨äºåŒ¹é…ã€‚
```rust
fn print_number(n: Number) {
    match n {
        Number { odd: true, value } => println!("Odd number: {}", value),
        Number { odd: false, value } => println!("Even number: {}", value),
    }
}
// è¾“å‡ºç»“æœå’Œä¸Šä¸€ä¸ªä¾‹å­ä¸€æ ·ã€‚
```

`match` åŒ¹é…å¿…é¡»ç©·å°½æ‰€æœ‰å¯èƒ½æ€§ï¼šè¾“å…¥è‡³å°‘èƒ½åŒ¹é…åˆ°ä¸€ä¸ªåˆ†æ”¯
```rust
fn print_number(n: Number) {
    match n {
        Number { value: 1, .. } => println!("One"),
        Number { value: 2, .. } => println!("Two"),
        Number { value, .. } => println!("{}", value),
        // å¦‚æœä¸å­˜åœ¨æœ€åä¸€ä¸ªåˆ†æ”¯ï¼Œåœ¨ç¼–è¯‘æ—¶å°±ä¼šæŠ¥é”™ã€‚
    }
}
```

å¦‚æœä¸Šé¢çš„å†™æ³•å¤ªå¤æ‚ï¼Œå¯ä»¥ä½¿ç”¨ `_` æ¥ä»£æ›¿ã€‚`_` å¯ä»¥ç”¨äºåŒ¹é…ä»»æ„è¾“å…¥
```rust
fn print_number(n: Number) {
    match n.value {
        1 => println!("One"),
        2 => println!("Two"),
        _ => println!("{}", n.value),
    }
}
```

## 8ã€ç»“æ„ä½“çš„æ–¹æ³•

ä½ å¯ä»¥ä¸ºè‡ªå®šä¹‰çš„ç»“æ„ä½“å£°æ˜æ–¹æ³•ï¼Œå¦‚ä¸‹æ‰€ç¤º:
```rust
struct Number {
    odd: bool,
    value: i32,
}

impl Number {
    fn is_strictly_positive(self) -> bool {
        self.value > 0
    }
}
```

å£°æ˜æ–¹æ³•è¿‡åï¼Œä½ å¯ä»¥åƒè¿™æ ·ä½¿ç”¨å®ƒä»¬
```rust
fn main() {
    let minus_two = Number {
        odd: false,
        value: -2,
    };
    println!("positive? {}", minus_two.is_strictly_positive());
// è¾“å‡ºï¼š
// positive? false
}
```

## 9ã€å†è°ˆå˜é‡ç»‘å®š

å˜é‡ç»‘å®šé»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼Œä¹Ÿå°±æ„å‘³ç€æ— æ³•ä¿®æ”¹å…¶å†…éƒ¨å€¼
```rust
fn main() {
    let n = Number {
        odd: true,
        value: 17,
    };
    n.odd = false; // error: cannot assign to `n.odd`,
                   // as `n` is not declared to be mutable
                   // è¯‘ï¼šä¸èƒ½ç»™ n.dd èµ‹å€¼ï¼Œå› ä¸º n æ²¡æœ‰è¢«å£°æ˜ä¸ºå¯å˜ã€‚
}
```
ä¸‹é¢è¿™æ ·ä¹Ÿä¸èƒ½èµ‹å€¼
```rust
fn main() {
    let n = Number {
        odd: true,
        value: 17,
    };
    n = Number {
        odd: false,
        value: 22,
    }; // error: cannot assign twice to immutable variable `n`
}      // è¯‘ï¼šä¸èƒ½ç»™ä¸å¯å˜å˜é‡ n èµ‹å€¼ä¸¤æ¬¡ã€‚
``` 
å¯ä»¥ `mut` å…³é”®å­—æ¥ä½¿å˜é‡ç»‘å®šå¯å˜ï¼š
```rust
fn main() {
    let mut n = Number {
        odd: true,
        value: 17,
    }
    n.value = 19; // æ­£å¸¸è¿è¡Œ
}
```

## 10ã€Trait

ç‰¹è´¨ï¼ˆTraitï¼‰å¯ä»¥åŒæ—¶è¢«å¤šç§ç±»å‹åŒæ—¶æ‹¥æœ‰ï¼š
```rust
trait Signed {
    fn is_strictly_negative(self) -> bool;
}
```
Trait çš„å­¤å„¿åŸåˆ™ï¼š
- åœ¨ä»»ä½•ç±»å‹ä¸Šéƒ½å¯ä»¥å®ç°ä½ çš„ Traitã€‚
- åœ¨ä½ è‡ªå®šä¹‰çš„ç±»å‹ä¸Šå¯ä»¥å®ç°ä»»æ„ Traitã€‚
- ä½†ä¸èƒ½åœ¨å¤–éƒ¨çš„ç±»å‹ä¸Šå®ç°å¤–éƒ¨çš„ Traitã€‚
> è¯‘è€…æ³¨ï¼šå¤–éƒ¨æ˜¯æŒ‡ä¸æ˜¯ç”±è‡ªå·±ï¼Œè€Œæ˜¯ç”±å¤–éƒ¨å®šä¹‰çš„ï¼ŒåŒ…æ‹¬æ ‡å‡†åº“ã€‚ä¾‹å¦‚ï¼šä¸èƒ½åœ¨æˆ‘ä»¬çš„ä»£ç /åº“é‡Œä¸º Vec å®ç° Display traitã€‚å› ä¸ºäºŒè€…éƒ½æ˜¯æ ‡å‡†åº“ï¼Œç›¸å¯¹äºä½ çš„ä»£ç è€Œè¨€æ˜¯å¤–éƒ¨çš„ã€‚

ä¸‹é¢åœ¨è‡ªå®šä¹‰çš„ç±»å‹ä¸Šå®ç°äº†è‡ªå·±çš„ Traitï¼š
```rust
impl Signed for Number {
    fn is_strictly_negative(self) -> bool {
        self.value < 0
    }
}

fn main() {
    let n = Number { odd: false, value: -44 };
    println!("{}", n.is_strictly_negative()); 
    // è¾“å‡ºï¼š true
}
```
åœ¨è‡ªå®šä¹‰çš„ç±»å‹ä¸Šå®ç°å¤–éƒ¨ Trait 
```rust
// åç§°ä¸º Neg çš„ Trait ç”¨äºé‡è½½è´Ÿå·â€œ-â€ã€‚
impl std::ops::Neg for Number {
    type Output = Number;

    fn neg(self) -> Number {
        Number {
            value: -self.value,
            odd: self.odd,
        }        
    }
}

fn main() {
    let n = Number { odd: true, value: 987 };
    let m = -n; // ä¸Šé¢å®ç°äº† Neg è¿™ä¸ª Traitï¼Œæ‰€ä»¥å¯ä»¥åœ¨ Number ç±»å‹çš„å˜é‡å‰ä½¿ç”¨è´Ÿå·ã€‚
    println!("{}", m.value); // è¾“å‡ºï¼š-987
}
```
`impl` ä»£ç å—æ€»æ˜¯å’ŒæŸç§ç±»å‹å…³è”ï¼Œå› æ­¤ï¼Œåœ¨ä»£ç å—ä¸­ï¼Œ`Self` æŒ‡å½“å‰ä»£ç å—å…³è”çš„ç±»å‹ã€‚
```rust
impl std::ops::Neg for Number {
    type Output = Self;

    fn neg(self) -> Self {
        Self {
            value: -self.value,
            odd: self.odd,
        }        
    }
}
```
ä¸€äº› Trait åªæ˜¯èµ·æ ‡è¯†ä½œç”¨ï¼Œè¿™äº› Trait ä¸éœ€è¦å®ç°ï¼Œå®ƒä»¬åªæ˜¯æ ‡è¯†è¿™ç§ç±»å‹å¯ä»¥åšæŸäº›äº‹ã€‚

ä¾‹å¦‚ï¼Œ`i32` å®ç°äº†åä¸º `Copy` çš„ Traitã€‚å› æ­¤ï¼Œä¸‹é¢çš„ä»£ç å¯ä»¥æ­£å¸¸è¿è¡Œ
```rust
fn main() {
    let a: i32 = 15;
    let b = a; // å˜é‡ a è¢«å¤åˆ¶
    let c = a; // å˜é‡ a è¢«å†æ¬¡å¤åˆ¶
}
``` 
ä¸‹é¢çš„ä»£ç ä¹Ÿå¯ä»¥æ­£å¸¸è¿è¡Œ
```rust
fn print_i32(x: i32) {
    println!("x = {}", x);
}

fn main() {
    let a: i32 = 15;
    print_i32(a); // `a` is copied
    print_i32(a); // `a` is copied again
}
```
ä½†æ˜¯ `Number` ç»“æ„ä½“å´æ²¡æœ‰ä½¿ç”¨ `Copy` è¿›è¡Œæ ‡è¯†ï¼Œæ‰€ä»¥ä¸‹é¢çš„ä»£ç ä¼šæŠ¥é”™ï¼š
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // å˜é‡ n è¢«ç§»åŠ¨åˆ°å˜é‡ mï¼ˆå˜é‡ n ä¼šè¢«é”€æ¯ï¼‰ã€‚ 
    let o = n; // error: use of moved value: `n`
               // è¯‘ï¼šé”™è¯¯ï¼šä½¿ç”¨å·²ç»è¢«ç§»åŠ¨çš„å˜é‡ nã€‚
}
```
ä¸‹é¢çš„ä»£ç ä¹Ÿä¼šæŠ¥é”™ï¼š
```rust
fn print_number(n: Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(n); // å˜é‡ n è¢«ç§»åŠ¨
    print_number(n); // error: use of moved value: `n`
                     // è¯‘ï¼šé”™è¯¯ï¼šä½¿ç”¨å·²ç»è¢«ç§»åŠ¨çš„å˜é‡ nã€‚
}
```     
å¦‚æœ `print_number` å‡½æ•°ä½¿ç”¨ä¸å¯å˜å¼•ç”¨æ›¿ä»£ä¸Šé¢çš„å†™æ³•ï¼Œå°±å¯ä»¥æ­£å¸¸è¿è¡Œ
```rust
fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(&n); // å˜é‡ n è¢«å€Ÿç”¨ã€‚
    print_number(&n); // å˜é‡ n è¢«å†æ¬¡å€Ÿç”¨ã€‚
}
```
å¦‚æœ `print_number` å‡½æ•°ä½¿ç”¨å¯å˜å¼•ç”¨ï¼Œå¹¶ä¸”å°†å˜é‡å£°æ˜ä¸ºå¯å˜å˜é‡ï¼Œä¹Ÿå¯ä»¥æ­£å¸¸è¿è¡Œ
```rust
fn invert(n: &mut Number) {
    n.value = -n.value;
}

fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    // å˜é‡ n æ˜¯å¯å˜
    let mut n = Number { odd: true, value: 51 };
    print_number(&n);
    invert(&mut n); // å¯å˜å€Ÿç”¨
    print_number(&n);
}
```
Trait æ–¹æ³•ä¹Ÿå¯ä»¥ä½¿ç”¨ `self` æ¥å¼•ç”¨å˜é‡è‡ªèº«ã€‚å³å¯ä»¥ä½¿ç”¨å¯å˜å¼•ç”¨ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸å¯å˜å¼•ç”¨ã€‚
```rust
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}
```
å½“è°ƒç”¨ Trait æ–¹æ³•æ—¶ï¼Œè°ƒç”¨è€…ä¼šè¢«éšå¼å€Ÿç”¨ã€‚
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let mut m = n.clone(); // éšå¼å€Ÿç”¨
    m.value += 100;
    
    print_number(&n);
    print_number(&m);
}
``` 
å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸‹é¢ä¸¤ç§å†™æ³•æ˜¯ç­‰ä»·çš„ï¼š
```rust
let m = n.clone();

let m = std::clone::Clone::clone(&n);
```
åƒ `Copy` è¿™æ ·èµ·æ ‡è¯†ä½œç”¨çš„ Traitï¼ˆä¹Ÿå«åš markerï¼‰ï¼Œä¸éœ€è¦å®ç°å…·ä½“çš„æ–¹æ³•ã€‚
```rust
// Noteï¼šClone éœ€è¦å®ç°æ–¹æ³•ã€‚
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}

impl std::marker::Copy for Number {}
```
`Clone` ä¹Ÿå¯ä»¥åƒä¸‹é¢è¿™æ ·ä½¿ç”¨
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n.clone();
    let o = n.clone();
}
```
`Number` çš„å€¼å°†ä¸ä¼šè¢«ç§»åŠ¨
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // å˜é‡ m æ˜¯å˜é‡ n çš„å‰¯æœ¬ï¼Œè€Œä¸æ˜¯æŠŠå˜é‡ n ç§»åŠ¨åˆ°å˜é‡ mã€‚
    let o = n; // åŒä¸Šã€‚
}
```
è¿™äº› Trait å¾ˆå¸¸ç”¨ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨ `derive` å±æ€§æ¥è‡ªåŠ¨å®ç°ï¼š
```rust
#[derive(Clone, Copy)]
struct Number {
    odd: bool,
    value: i32,
}

// ä¸Šé¢å®ç°äº† Copy å’Œ Clone ä¸¤ä¸ª Traitï¼Œä¸ä¸Šé¢çš„ `impl Clone for Number`ã€`impl Copy for Number`çš„ä»£ç å—æ•ˆæœä¸€æ ·ã€‚
```

## 11ã€æ³›å‹

å‡½æ•°å¯ä»¥å£°æ˜ä¸ºæ³›å‹ï¼š
```rust
fn foobar<T>(arg: T) {
    // ä½¿ç”¨ arg å‚æ•°
}
```
å‡½æ•°å¯ä»¥æœ‰å¤šç§å‚æ•°ç±»å‹ï¼Œè€Œä¸æ˜¯æŸç§å›ºå®šçš„ç±»å‹ã€‚
```rust
fn foobar<L, R>(left: L, right: R) {
    // ä½¿ç”¨ left å’Œ right å‚æ•°
}
```
æ³›å‹çš„å‚æ•°ç±»å‹å¯ä»¥è®¾ç½®çº¦æŸæ¡ä»¶ã€‚æœ€ç®€å•çš„çº¦æŸæ¡ä»¶å°±æ˜¯ Trait åç§°
```rust
fn print<T: Display>(value: T) {
    println!("value = {}", value);
}

fn print<T: Debug>(value: T) {
    println!("value = {:?}", value);
}
```
ä¹Ÿå¯ä»¥å†™æˆä¸‹é¢è¿™æ ·
```rust
fn print<T>(value: T)
where
    T: Display,
{
    println!("value = {}", value);
}
```
æ³›å‹çš„å‚æ•°ç±»å‹è¿˜å¯ä»¥æ›´å¤æ‚ï¼šå¯ä»¥è¦æ±‚å‚æ•°ç±»å‹åŒæ—¶å®ç°å¤šç§ Traitã€‚
```rust
use std::fmt::Debug;

fn compare<T>(left: T, right: T)
where
    T: Debug + PartialEq,
{
    println!("{:?} {} {:?}", left, if left == right { "==" } else { "!=" }, right);
}

fn main() {
    compare("tea", "coffee");
    // è¾“å‡º: "tea" != "coffee"
}
```
æ³›å‹å‡½æ•°å¯ä»¥è¢«è®¤ä¸ºæ˜¯å‘½åç©ºé—´ï¼Œå®ƒåŒ…å«æ— æ•°å…·ä½“ç±»å‹çš„å‡½æ•°ã€‚

å’ŒåŒ…ï¼ˆcrateï¼‰ã€æ¨¡å—ï¼ˆmoduleï¼‰ã€ç±»å‹ï¼ˆTypeï¼‰ä¸€æ ·ï¼Œæ³›å‹å‡½æ•°å¯ä»¥ä½¿ç”¨ `::` æ¥è®¿é—®æŸç§å…·ä½“ç±»å‹çš„å‡½æ•°ã€‚ä¾‹å¦‚ï¼š
```rust
fn main() {
    use std::any::type_name;
    println!("{}", type_name::<i32>()); // è¾“å‡ºï¼ši32
    println!("{}", type_name::<(f64, char)>()); // è¾“å‡ºï¼š(f64, char)
}
```
è¿™ç§è¯­æ³•è¢«äº²åˆ‡çš„ç§°ä¸º Turbofish è¯­æ³•ï¼ˆæ¶¡è½®é±¼è¯­æ³•ï¼‰ï¼Œå› ä¸º `::<>` çœ‹èµ·æ¥åƒæ˜¯ä¸€æ¡é±¼ã€‚

ç»“æ„ä½“ä¹Ÿå¯ä»¥æ˜¯æ³›å‹ï¼š
```rust
struct Pair<T> {
    a: T,
    b: T,
}

fn print_type_name<T>(_val: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let p1 = Pair { a: 3, b: 9 };
    let p2 = Pair { a: true, b: false };
    print_type_name(&p1); // è¾“å‡ºï¼šPair<i32>
    print_type_name(&p2); // è¾“å‡ºï¼šPair<bool>
}
```
æ ‡å‡†åº“ä¸­çš„ `Vec` ä¹Ÿæ˜¯æ³›å‹ï¼š
```rust
fn main() {
    let mut v1 = Vec::new();
    v1.push(1);
    let mut v2 = Vec::new();
    v2.push(false);
    print_type_name(&v1); // è¾“å‡ºï¼šVec<i32>
    print_type_name(&v2); // è¾“å‡ºï¼šVec<bool>
}
```
`Vec` é…å¤‡äº†ä¸€ä¸ªå®ï¼Œè®©æˆ‘ä»¬å¯ä»¥åœ¨å£°æ˜ `Vec` çš„æ—¶å€™è¿›è¡Œåˆå§‹åŒ–ã€‚
```rust
fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![true, false, true];
    print_type_name(&v1); // prints "Vec<i32>"
    print_type_name(&v2); // prints "Vec<bool>"
}
```

## 12ã€å®

`name!()`ã€`name![]`ã€`name!{}` éƒ½æ˜¯è°ƒç”¨å®ï¼Œå®ä¼šè¢«å±•å¼€æˆå…¶å®ƒä»£ç ã€‚

äº‹å®ä¸Šï¼Œ`println` å°±æ˜¯ä¸€ä¸ªå®ï¼š
```rust
fn main() {
    println!("{}", "Hello there!");
}
```
å®å±•å¼€åçš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š
```rust
fn main() {
    use std::io::{self, Write};
    io::stdout().lock().write_all(b"Hello there!\n").unwrap();
}
```
`panic` ä¹Ÿæ˜¯ä¸€ä¸ªå®ï¼Œå®ƒä¼šç«‹å³åœæ­¢ç¨‹åºå¹¶è¾“å‡ºé”™è¯¯ä¿¡æ¯ï¼š
```rust
fn main() {
    panic!("This panics");
}
// è¾“å‡º: thread 'main' panicked at 'This panics', src/main.rs:3:5
// è¯‘ï¼šçº¿ç¨‹ main çš„å¼‚å¸¸ä½äº â€œThis panicsâ€ï¼Œsrc/main. rs:3:5
```
ä¸€äº›å‡½æ•°ä¹Ÿä½¿ç”¨åˆ°äº† `panic`ã€‚æ¯”å¦‚ `Option` ç±»å‹ä¸­çš„ `unwrap` å‡½æ•°ã€‚

`Option` æ˜¯ä¸€ç§æšä¸¾ç±»å‹ï¼Œå¯ä»¥åŒ…å«å€¼ï¼Œä¹Ÿå¯ä»¥ä¸ºç©ºã€‚å½“ `Option` ä¸ºç©ºæ—¶ï¼Œè°ƒç”¨ `unwrap()` å‡½æ•°å°±ä¼šé€ æˆ `panic`ã€‚
```rust
fn main() {
    let o1: Option<i32> = Some(128);
    o1.unwrap(); // æ­£å¸¸æ‰§è¡Œ

    let o2: Option<i32> = None;
    o2.unwrap(); // panic å¼‚å¸¸
}
// è¾“å‡º: thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21
// è¯‘ï¼šçº¿ç¨‹ main çš„å¼‚å¸¸çš„åŸå› æ˜¯ï¼Œåœ¨å€¼ä¸º None çš„å˜é‡ä¸Šè°ƒç”¨ `Option::unwrap()` å‡½æ•°ï¼Œsrc/libcore/option.rs:378:21
```
`Option` ä¸æ˜¯ç»“æ„ä½“ï¼Œè€Œæ˜¯æšä¸¾ç±»å‹ã€‚`Option` ç±»å‹åªæœ‰ä¸¤ç§å€¼ï¼Œè¦ä¹ˆæ˜¯ `Some(T)`, è¦ä¹ˆä¸º `None`ã€‚
```rust
enum Option<T> {
    None,
    Some(T),
}

impl<T> Option<T> {
    fn unwrap(self) -> T {
        // æšä¸¾å˜é‡å¯ä»¥ç”¨äºæ¨¡å¼åŒ¹é…ã€‚
        match self {
            Self::Some(t) => t,
            Self::None => panic!(".unwrap() called on a None option"),
        }
    }
}

use self::Option::{None, Some};

fn main() {
    let o1: Option<i32> = Some(128);
    o1.unwrap(); // æ­£å¸¸è¿è¡Œ

    let o2: Option<i32> = None;
    o2.unwrap(); // panic å¼‚å¸¸
}

// è¾“å‡º: thread 'main' panicked at '.unwrap() called on a None option', src/main.rs:11:27
// è¯‘ï¼šçº¿ç¨‹ main çš„å¼‚å¸¸çš„åŸå› æ˜¯ï¼Œåœ¨å€¼ä¸º None çš„å˜é‡ä¸Šè°ƒç”¨ `Option::unwrap()` å‡½æ•°ï¼Œsrc/main.rs:11:27
```
`Result` ä¹Ÿæ˜¯ä¸€ç§æšä¸¾ç±»å‹ï¼Œç±»ä¼¼ `Option`ï¼Œå®ƒä¹Ÿåªæœ‰ä¸¤ç§å€¼ï¼Œè¦ä¹ˆæ˜¯ `Ok(T)`ï¼Œè¦ä¹ˆæ˜¯ `Err(E)`ã€‚
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
å½“ `Result` çš„å€¼ä¸º `Err(E)` æ—¶ï¼Œè°ƒç”¨ `unwrap()` å‡½æ•°ä¹Ÿä¼šé€ æˆ `panic`ã€‚

## 13ã€ç”Ÿå‘½å‘¨æœŸ

å˜é‡ç»‘å®šæ˜¯æœ‰ç”Ÿå‘½å‘¨æœŸçš„ã€‚
```rust
fn main() {
    // å˜é‡ x ä¸å­˜åœ¨
    {
        let x = 42; // å˜é‡ x å­˜åœ¨
        println!("x = {}", x);
        // å˜é‡ X è¢«é”€æ¯
    }
    // å˜é‡ x ä¸å­˜åœ¨
}
```
ç±»ä¼¼çš„ï¼Œå¼•ç”¨ä¹Ÿæœ‰ç”Ÿå‘½å‘¨æœŸã€‚
```rust
fn main() {
    // å˜é‡ x ä¸å­˜åœ¨
    {
        let x = 42; // å˜é‡ x å­˜åœ¨
        let x_ref = &x; // å˜é‡ x_ref å­˜åœ¨ï¼Œå¹¶ä¸”å€Ÿç”¨äº†å˜é‡ xã€‚
        println!("x_ref = {}", x_ref);
        // å˜é‡ x_ref è¢«é”€æ¯
        // å˜é‡ x è¢«é”€æ¯
    }
    // å˜é‡ x ä¸å­˜åœ¨
}
```
å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸å¯ä»¥è¶…è¿‡è¢«å€Ÿç”¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸã€‚
```rust
fn main() {
    let x_ref = {
        let x = 42;
        &x
    };
    println!("x_ref = {}", x_ref);
    // error: `x` does not live long enough
    // è¯‘ï¼šå˜é‡ x å·²ç»è¢«é”€æ¯
}
```
ä¸€ä¸ªå˜é‡ç»‘å®šå¯ä»¥å¤šæ¬¡è¢«ä¸å¯å˜å€Ÿç”¨
```rust
fn main() {
    let x = 42;
    let x_ref1 = &x;
    let x_ref2 = &x;
    let x_ref3 = &x;
    println!("{} {} {}", x_ref1, x_ref2, x_ref3);
}
```
å˜é‡ç»‘å®šè¢«å€Ÿç”¨çš„æ—¶å€™ï¼Œå˜é‡ä¸èƒ½è¢«ä¿®æ”¹ã€‚
```rust
fn main() {
    let mut x = 42;
    let x_ref = &x;
    x = 13;
    println!("x_ref = {}", x_ref);
    // error: cannot assign to `x` because it is borrowed
    // è¯‘ï¼šé”™è¯¯ï¼šä¸èƒ½ç»™å˜é‡ x èµ‹å€¼ï¼Œå› ä¸º x å·²ç»è¢«å€Ÿç”¨ã€‚
}
```
å˜é‡ç»‘å®šè¢«ä¸å¯å˜å€Ÿç”¨çš„æ—¶å€™ï¼Œä¸èƒ½å†è¢«å¯å˜å€Ÿç”¨ã€‚
```rust
fn main() {
    let mut x = 42;
    let x_ref1 = &x;
    let x_ref2 = &mut x;
    // error: cannot borrow `x` as mutable because it is also borrowed as immutable
    // è¯‘ï¼šé”™è¯¯ï¼šä¸èƒ½å°†å˜é‡ x ä½œä¸ºå¯å˜å€Ÿç”¨ï¼Œå› ä¸ºå˜é‡ x å·²ç»è¢«ä¸å¯å˜å€Ÿç”¨ã€‚
    println!("x_ref1 = {}", x_ref1);
}
```
å‡½æ•°å‚æ•°ä¸­çš„å¼•ç”¨ä¹Ÿæœ‰ç”Ÿå‘½å‘¨æœŸã€‚
```rust
fn print(x: &i32) {
    // å˜é‡ x æ˜¯å¤–éƒ¨å˜é‡çš„å€Ÿç”¨ã€‚å½“å‡½æ•°è¢«é”€æ¯æ—¶ï¼Œå˜é‡ x ä¹Ÿä¼šè¢«é”€æ¯ã€‚
}
```

ä¸€ä¸ªå‡½æ•°å¯ä»¥æ‹¥æœ‰ä¸åŒç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨å‚æ•°ï¼Œå› æ­¤ï¼Œå‡½æ•°æ¯ä¸€ä¸ªå¼•ç”¨å‚æ•°éƒ½æœ‰å¯¹åº”çš„æ³›å‹ç”Ÿå‘½å‘¨æœŸã€‚
> è¯‘è€…æ³¨ï¼šä¸€ä¸ªå¼•ç”¨å‚æ•°çš„å‡½æ•°å°±æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸæ ‡æ³¨: `fn foo<'a>(x: &'a i32)`ï¼Œä¸¤ä¸ªå¼•ç”¨å‚æ•°çš„æœ‰ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸæ ‡æ³¨:`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`, ä¾æ­¤ç±»æ¨ã€‚

ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä»¥å•å¼•å· `'` å¼€å¤´
```rust
// çœç•¥ç”Ÿå‘½å‘¨æœŸï¼ˆæ²¡æœ‰åå­—çš„ç”Ÿå‘½å‘¨æœŸï¼‰ï¼š
fn print(x: &i32) {}

// å‘½åç”Ÿå‘½å‘¨æœŸ:
fn print<'a>(x: &'a i32) {}
```
å‡½æ•°å¯ä»¥è¿”å›å¼•ç”¨ï¼Œè¿”å›çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¾èµ–äºå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸï¼š
```rust
struct Number {
    value: i32,
}

fn number_value<'a>(num: &'a Number) -> &'a i32 {
    &num.value
}

fn main() {
    let n = Number { value: 47 };
    let v = number_value(&n);
    // å˜é‡ v ä¸å¯å˜çš„å€Ÿç”¨å˜é‡ nï¼Œå› æ­¤å˜é‡ v çš„ç”Ÿå‘½å‘¨æœŸä¸è¶…è¿‡å˜é‡ n çš„ç”Ÿå‘½å‘¨æœŸã€‚
    // å½“å˜é‡ v å­˜åœ¨æ—¶ï¼Œå˜é‡ n ä¸èƒ½è¢«å¯å˜çš„å€Ÿç”¨ã€ä¸èƒ½ä¿®æ”¹ï¼Œä¹Ÿä¸èƒ½è¢«ç§»åŠ¨ã€‚
}
```
å½“åªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œå¯ä»¥ä¸å‘½åã€‚æ‰€æœ‰çš„å˜é‡éƒ½æ‹¥æœ‰åŒä¸€ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œå› æ­¤ï¼Œä¸‹é¢ä¸¤ä¸ªå‡½æ•°æ˜¯ç­‰ä»·çš„ï¼š
> è¯‘è€…æ³¨ï¼šå‡½æ•°æˆ–è€…æ–¹æ³•ä¸­ï¼Œå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸè¢«ç§°ä¸º`è¾“å…¥ç”Ÿå‘½å‘¨æœŸ`ï¼Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸè¢«ç§°ä¸º`è¾“å‡ºç”Ÿå‘½å‘¨æœŸ`ã€‚
```rust
fn number_value<'a>(num: &'a Number) -> &'a i32 {
    &num.value
}

fn number_value(num: &Number) -> &i32 {
    &num.value
}
```
åœ¨ç»“æ„ä½“ä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å¼•ç”¨ï¼Œä½†éœ€è¦ç»™æ¯ä¸ªå¼•ç”¨éƒ½æ ‡æ³¨ä¸Šç”Ÿå‘½å‘¨æœŸã€‚
```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn main() {
    let x: i32 = 99;
    let x_ref = NumRef { x: &x };
    // å˜é‡ x_ref ç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡å˜é‡ x çš„ç”Ÿå‘½å‘¨æœŸã€‚
}
```
ä»£ç åŒä¸Šï¼Œä½†ä½¿ç”¨äº†å‡½æ•°æ¥åˆ›å»º NumRefï¼š
```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn as_num_ref<'a>(x: &'a i32) -> NumRef<'a> {
    NumRef { x: &x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&x);
    // å˜é‡ x_ref ç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡å˜é‡ x çš„ç”Ÿå‘½å‘¨æœŸã€‚
}
```
ä»£ç åŒä¸Šï¼Œä½†ä½¿ç”¨äº†çœç•¥ç”Ÿå‘½å‘¨æœŸï¼š
```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn as_num_ref(x: &i32) -> NumRef<'_> {
    NumRef { x: &x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&x);
   // å˜é‡ x_ref ç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡å˜é‡ x çš„ç”Ÿå‘½å‘¨æœŸã€‚
}
```
`impl` å—ä¹Ÿå¯ä»¥ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸï¼š
```rust
impl<'a> NumRef<'a> {
    fn as_i32_ref(&'a self) -> &'a i32 {
        self.x
    }
}

fn main() {
    let x: i32 = 99;
    let x_num_ref = NumRef { x: &x };
    let x_i32_ref = x_num_ref.as_i32_ref();
    // å˜é‡ x_num_ref å’Œå˜é‡ x_i32_ref çš„ç”Ÿå‘½å‘¨æœŸéƒ½æ¯”å˜é‡ x çš„ç”Ÿå‘½å‘¨æœŸçŸ­ã€‚
}
```
å½“ç„¶ï¼Œ`impl` å—ä¹Ÿå¯ä»¥ä½¿ç”¨çœç•¥ç”Ÿå‘½å‘¨æœŸï¼š
```rust
impl<'a> NumRef<'a> {
    fn as_i32_ref(&self) -> &i32 {
        self.x
    }
}
```
è¿˜å¯ä»¥çœç•¥æ›´å¤šï¼š
```rust
impl NumRef<'_> {
    fn as_i32_ref(&self) -> &i32 {
        self.x
    }
}
```
æœ‰ä¸€ç§ç‰¹æ®Šçš„ç”Ÿå‘½å‘¨æœŸï¼Œå«åš`'static`ï¼Œæ‹¥æœ‰è¯¥ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨å¯ä»¥å’Œæ•´ä¸ªç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ã€‚
```rust
struct Person {
    name: &'static str,
}

fn main() {
    let p = Person {
        name: "fasterthanlime",
    };
}
```
ä½†æ‹¥æœ‰æ‰€æœ‰æƒçš„å­—ç¬¦ä¸²ä¸æ˜¯é™æ€çš„ï¼š
```rust
struct Person {
    name: &'static str,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: &name };
    // error: `name` does not live long enough
    // è¯‘ï¼šé”™è¯¯ï¼šå˜é‡ name ç”Ÿå‘½å‘¨æœŸä¸å¤Ÿé•¿ã€‚
}
```
åœ¨ä¸Šä¸€ä¸ªä¾‹å­ä¸­ï¼Œå˜é‡ name ä¸èƒ½ä½œä¸ºé™æ€å­—ç¬¦ä¸²çš„å¼•ç”¨ï¼ˆå³ `&'static str`ï¼‰ã€‚å˜é‡ name æ˜¯è¢«åŠ¨æ€åˆ†é…çš„ï¼Œä¼šè¢«è‡ªåŠ¨é‡Šæ”¾ã€‚å®ƒçš„ç”Ÿå‘½å‘¨æœŸæ˜¯çŸ­äºæ•´ä¸ªç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸã€‚
> è¯‘è€…æ³¨ï¼šæ³¨æ„åŒºåˆ† `String` ç±»å‹å’Œ `str` ç±»å‹ã€‚åªæœ‰ `str` ç±»å‹æ‰èƒ½ä½œä¸ºé™æ€å­—ç¬¦ä¸²çš„å¼•ç”¨ï¼Œ`format!` å®çš„è¿”å›å€¼æ˜¯ `String` ç±»å‹ã€‚

å­˜å‚¨ä¸€ä¸ªéé™æ€çš„å­—ç¬¦ä¸²åˆ° `Person` ä¸­ï¼Œå¯ä»¥è€ƒè™‘ï¼š

Aï¼‰ä½¿ç”¨æ™®é€šçš„ç”Ÿå‘½å‘¨æœŸ
```rust
struct Person<'a> {
    name: &'a str,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: &name };
    // å˜é‡ p çš„ç”Ÿå‘½å‘¨æœŸçŸ­äºå˜é‡ name çš„ç”Ÿå‘½å‘¨æœŸã€‚
}
```
Bï¼‰è·å–å­—ç¬¦ä¸²çš„æ‰€æœ‰æƒã€‚
```rust
struct Person {
    name: String,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: name };
    // `name` was moved into `p`, their lifetimes are no longer tied.
}
```
åœ¨ç»“æ„ä½“ä¸­ï¼Œå¦‚æœå­—æ®µçš„åç§°å’Œå˜é‡ç»‘å®šçš„åç§°ç›¸åŒï¼Œå¦‚ä¸‹æ‰€ç¤º
```rust
let p = Person { name: name };
```
å¯ä»¥åƒä¸‹é¢è¿™æ ·ç®€å†™ï¼š
```rust
let p = Person { name };
```
<!-- todo -->
åœ¨ Rust ä¸­ï¼Œè®¸å¤šç±»å‹éƒ½æœ‰æ‹¥æœ‰æ‰€æœ‰æƒæˆ–å¼•ç”¨çš„å˜ä½“ã€‚
- Stringsï¼š`String` ç±»å‹æ‹¥æœ‰æ‰€æœ‰æƒï¼Œ`&str` æ˜¯å¼•ç”¨ã€‚
- Pathï¼š`PathBuf` ç±»å‹æ‹¥æœ‰æ‰€æœ‰æƒï¼Œ`&Path` æ˜¯å¼•ç”¨ã€‚
- Collectionsï¼š`Vec<T>` ç±»å‹æ‹¥æœ‰æ‰€æœ‰æƒï¼Œ`&[T]` æ˜¯å¼•ç”¨ã€‚

## 14ã€åˆ‡ç‰‡

Rust æ‹¥æœ‰åˆ‡ç‰‡â€”â€”å¤šä¸ªå…ƒç´ çš„å¼•ç”¨ã€‚

ä½ å¯ä»¥å€Ÿç”¨ä¸€å—æ•°ç»„ï¼Œä¾‹å¦‚ï¼š
```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let v2 = &v[2..4];
    println!("v2 = {:?}", v2);
}

// è¾“å‡º:
// v2 = [3, 4]
```
ä¸Šé¢ä¸æ˜¯é­”æ³•ã€‚`Index` å’Œ `IndexMut` è¿™ä¸¤ä¸ª Trait é‡è½½ç´¢å¼•æ“ä½œç¬¦ `foo[index]`ã€‚

`..` è¯­æ³•æ˜¯ Range çš„å­—é¢é‡ã€‚åœ¨æ ‡å‡†åº“ä¸­ï¼Œåªæœ‰å°‘é‡çš„ç»“æ„å¯ä»¥ç›´æ¥ä½¿ç”¨ Rangeã€‚

ä»–ä»¬æ˜¯åŠé—­åŠå¼€çš„ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨ `=` ç¬¦å·æ¥è®©å³ä¾§é—­åˆã€‚
```rust
fn main() {
    // å¤§äº 0 çš„æ‰€æœ‰æ•°å­—
    println!("{:?}", (0..).contains(&100)); // true
    // å°äº 20 çš„æ‰€æœ‰æ•°å­—
    println!("{:?}", (..20).contains(&20)); // false
    // å°äºç­‰äº 20 çš„æ‰€æœ‰æ•°å­—
    println!("{:?}", (..=20).contains(&20)); // true
    // 3ã€4ã€5
    println!("{:?}", (3..6).contains(&4)); // true
}
```
å€Ÿç”¨è§„åˆ™ä¹Ÿå¯ä»¥ç”¨åœ¨åˆ‡ç‰‡è¿™
```rust
fn tail(s: &[u8]) -> &[u8] {
  &s[1..] 
}

fn main() {
    let x = &[1, 2, 3, 4, 5];
    let y = tail(x);
    println!("y = {:?}", y);
}
```
ä»£ç åŒä¸Šï¼š
```rust
fn tail<'a>(s: &'a [u8]) -> &'a [u8] {
  &s[1..] 
}

fn main() {
    let y = {
        let x = &[1, 2, 3, 4, 5];
        // [1, 2, 3, 4, 5] ç±»ä¼¼ strï¼Œç¡¬ç¼–ç åˆ°ç¨‹åºä¸­ï¼Œç”Ÿå‘½å‘¨æœŸæ˜¯ `'static`ã€‚
        tail(x)
    };
    println!("y = {:?}", y);
}
```
ä½†ä¸‹é¢çš„å†™æ³•ä¸æ­£ç¡®ï¼š
```rust
fn main() {
    let y = {
        let v = vec![1, 2, 3, 4, 5];
        tail(&v)
        // error: `v` does not live long enough
        // è¯‘ï¼šå˜é‡ v æ´»å¾—ä¸å¤Ÿé•¿ï¼ˆç”Ÿå‘½å‘¨æœŸå¤ªçŸ­ï¼‰
    };
    println!("y = {:?}", y);
}
```
è¿™é‡Œçš„ `vector` æ˜¯åœ¨å †ä¸Šåˆ†é…çš„ï¼Œä¼šè¢«è‡ªåŠ¨é‡Šæ”¾ã€‚

å­—ç¬¦ä¸²çš„åˆ‡ç‰‡åè¿”å›çš„ç±»å‹æ˜¯ `&str`
```rust
fn file_ext(name: &str) -> Option<&str> {
    // ä¸åˆ›å»ºæ–°çš„å­—ç¬¦ä¸²
    name.split(".").last()
}

fn main() {
    let name = "Read me. Or don't.txt";
    if let Some(ext) = file_ext(name) {
        println!("file extension: {}", ext);
    } else {
        println!("no file extension");
    }
}
```
å€Ÿç”¨è§„åˆ™ä¹Ÿå¯ä»¥ç”¨äºå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼š
```rust
fn main() {
    let ext = {
        let name = String::from("Read me. Or don't.txt");
        file_ext(&name).unwrap_or("")
        // error: `name` does not live long enough
        // è¯‘ï¼šé”™è¯¯ï¼šå˜é‡ name æ´»å¾—ä¸å¤Ÿé•¿ã€‚
    };
    println!("extension: {:?}", ext);
}
```
å‡½æ•°é€šå¸¸ä¼šè¿”å› `Result` ç±»å‹ï¼š
```rust
fn main() {
    let s = std::str::from_utf8(&[240, 159, 141, 137]);
    println!("{:?}", s);
    // è¾“å‡º: Ok("ğŸ‰")

    let s = std::str::from_utf8(&[195, 40]);
    println!("{:?}", s);
    // è¾“å‡º: Err(Utf8Error { valid_up_to: 0, error_len: Some(1) })
}
```

## 15ã€å¼‚å¸¸å¤„ç†

å¦‚æœä½ å¸Œæœ›åœ¨æ‰§è¡Œé”™è¯¯å panicï¼Œä½ å¯ä»¥ä½¿ç”¨ `.unwrap()`ï¼š
```rust
fn main() {
    let s = std::str::from_utf8(&[240, 159, 141, 137]).unwrap();
    println!("{:?}", s);
    // è¾“å‡º: "ğŸ‰"

    let s = std::str::from_utf8(&[195, 40]).unwrap();
    // è¾“å‡º: thread 'main' panicked at 'called `Result::unwrap()`
    // on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }',
    // src/libcore/result.rs:1165:5
    // è¯‘ï¼šçº¿ç¨‹ main å‘ç”Ÿå¼‚å¸¸ï¼ŒåŸå› ä¸ºåœ¨ `Err` ç±»å‹ä¸Šè°ƒç”¨ `Result::unwrap()` å‡½æ•°ï¼šUtf8Error { valid_up_to: 0, error_len: Some(1) }', src/libcore/result.rs:1165:5
}
```
ä½¿ç”¨ `.expect()` å¯ä»¥è‡ªå®šä¹‰æ¶ˆæ¯ï¼š
```rust
fn main() {
    let s = std::str::from_utf8(&[195, 40]).expect("valid utf-8");
    // è¾“å‡º: thread 'main' panicked at 'valid utf-8: Utf8Error
    // { valid_up_to: 0, error_len: Some(1) }', src/libcore/result.rs:1165:5
    // è¯‘ï¼šçº¿ç¨‹ main å‘ç”Ÿå¼‚å¸¸ï¼ŒåŸå› ä¸º valid utf-8ï¼šUtf8Error { valid_up_to: 0, error_len: Some(1) }', src/libcore/result.rs:1165:5
}
```
æˆ–è€…ï¼Œä½¿ç”¨ `match` æ¥å¤„ç†å¼‚å¸¸ï¼š
```rust
fn main() {
    match std::str::from_utf8(&[240, 159, 141, 137]) {
        Ok(s) => println!("{}", s),
        Err(e) => panic!(e),
    }
    // è¾“å‡ºï¼š ğŸ‰
}
```
è¿˜å¯ä»¥ä½¿ç”¨ `if let`ï¼š
```rust
fn main() {
    if let Ok(s) = std::str::from_utf8(&[240, 159, 141, 137]) {
        println!("{}", s);
    }
    // è¾“å‡º ğŸ‰
}
```
å°†å¼‚å¸¸ä¼ é€’å‡ºå»ï¼š
```rust
fn main() -> Result<(), std::str::Utf8Error> {
    match std::str::from_utf8(&[240, 159, 141, 137]) {
        Ok(s) => println!("{}", s),
        Err(e) => return Err(e),
    }
    Ok(())
}
```
å¯ä»¥ä½¿ç”¨ `?` æ¥ç®€å†™ï¼š
```rust
fn main() -> Result<(), std::str::Utf8Error> {
    let s = std::str::from_utf8(&[240, 159, 141, 137])?;
    println!("{}", s);
    Ok(())
}
```

## 16ã€è§£å¼•ç”¨

`*` æ“ä½œç¬¦å¯ä»¥ç”¨äºè§£æ„å¼•ç”¨ï¼Œä½†å½“ä½ è®¿é—®å­—æ®µæˆ–è€…è°ƒç”¨æ–¹æ³•æ—¶ä¸éœ€è¦æ‰‹åŠ¨æ ‡æ³¨ï¼š
```rust
struct Point {
    x: f64,
    y: f64,
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &p;
    println!("({}, {})", p_ref.x, p_ref.y);
}

// è¾“å‡ºï¼š (1, 3)
```
åªæœ‰ç±»å‹å®ç°äº† Copy Traitï¼Œæ‰èƒ½åƒä¸‹é¢è¿™æ ·ä½¿ç”¨ï¼Œå¦åˆ™å°±ä¼šæŠ¥é”™ï¼š
```rust
struct Point {
    x: f64,
    y: f64,
}

fn negate(p: Point) -> Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &p;
    negate(*p_ref);
    // error: cannot move out of `*p_ref` which is behind a shared reference
    // è¯‘ï¼šé”™è¯¯ï¼šä¸èƒ½ç§»å‡ºå…±äº«å¼•ç”¨åé¢çš„ *p_ref
}
```
å®ç° Copy Trait åå³å¯æ­£å¸¸è¿è¡Œï¼š
```rust
// å®ç° Copy Trait
#[derive(Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

fn negate(p: Point) -> Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &p;
    negate(*p_ref); 
}
```

## 17ã€é—­åŒ…

é—­åŒ…å‡½æ•°æœ‰ä¸‰ç§ç±»å‹ï¼Œä»–ä»¬åˆ†åˆ«æ˜¯ `Fn`ã€`FnMut`ã€`FnOnce`ã€‚

é—­åŒ…å‡½æ•°çš„å‚æ•°å†™åœ¨ä¸€å¯¹ç®¡é“ç¬¦ `|` ä¹‹é—´ï¼Œå¹¶ä½¿ç”¨é€—å·åˆ†å¼€ã€‚å¦‚æœé—­åŒ…åªæœ‰ä¸€æ¡è¯­å¥ï¼Œå¯ä»¥ä¸ç”¨å†™å¤§æ‹¬å·ã€‚
```rust
fn for_each_planet<F>(f: F)
    where F: Fn(&'static str)
{
    f("Earth");
    f("Mars");
    f("Jupiter");
}
 
fn main() {
    for_each_planet(|planet| println!("Hello, {}", planet));
}

// è¾“å‡º:
// Hello, Earth
// Hello, Mars
// Hello, Jupiter
```
å€Ÿç”¨è§„åˆ™ä¹Ÿå¯ä»¥ç”¨äºé—­åŒ…å‡½æ•°ï¼š
```rust
fn for_each_planet<F>(f: F)
    where F: Fn(&'static str)
{
    f("Earth");
    f("Mars");
    f("Jupiter");
}
 
fn main() {
    let greeting = String::from("Good to see you");
    for_each_planet(|planet| println!("{}, {}", greeting, planet));
    // é—­åŒ…å€Ÿç”¨äº† greetingï¼Œ
}
```
ä¸‹é¢çš„ä»£ç ä¼šæŠ¥é”™ï¼š
```rust
fn for_each_planet<F>(f: F)
    where F: Fn(&'static str) + 'static // F å¿…é¡»æ˜¯é™æ€ç”Ÿå‘½å‘¨æœŸã€‚
{
    f("Earth");
    f("Mars");
    f("Jupiter");
}

fn main() {
    let greeting = String::from("Good to see you");
    for_each_planet(|planet| println!("{}, {}", greeting, planet));
    
    // error: closure may outlive the current function, but it borrows
    // `greeting`, which is owned by the current function
    // è¯‘ï¼šé”™è¯¯ï¼Œé—­åŒ…æ¯”å½“å‰å‡½æ•°æ´»å¾—æ›´ä¹…ï¼Œä½†é—­åŒ…å€Ÿç”¨äº†å˜é‡ greetingï¼Œå½“å‰å‡½æ•°æ‹¥æœ‰å˜é‡ greeting çš„æ§åˆ¶æƒã€‚ 
}
```
ç¨å¾®ä¿®æ”¹ä¸€ä¸‹å°±èƒ½æ­£å¸¸è¿è¡Œäº†ï¼š
```rust
fn main() {
    let greeting = String::from("You're doing great");
    for_each_planet(move |planet| println!("{}, {}", greeting, planet));
    // å˜é‡ greeting ä¸æ˜¯è¢«å€Ÿç”¨åˆ°é—­åŒ…ä¸­ï¼Œè€Œæ˜¯è¢«ç§»åŠ¨åˆ°é—­åŒ…ä¸­ï¼Œé—­åŒ…æ‹¥æœ‰å˜é‡ greeting çš„æ‰€æœ‰æƒã€‚
}
```
`FnMut` å‡½æ•°åœ¨è¢«è°ƒç”¨æ—¶ï¼Œéœ€è¦å¯å˜çš„å€Ÿç”¨å‚æ•°ï¼Œå› æ­¤å®ƒåªèƒ½è¢«è°ƒç”¨ä¸€æ¬¡ã€‚

åˆæ³•çš„ä»£ç ï¼š
```rust
fn foobar<F>(f: F)
    where F: Fn(i32) -> i32
{
    println!("{}", f(f(2))); 
}
 
fn main() {
    foobar(|x| x * 2);
}

// è¾“å‡ºï¼š 8
```
ä¸‹é¢çš„ä»£ç ä¼šæŠ¥é”™ï¼š
```rust
fn foobar<F>(mut f: F)
    where F: FnMut(i32) -> i32
{
    println!("{}", f(f(2))); 
    // error: cannot borrow `f` as mutable more than once at a time
    // è¯‘ï¼šä¸èƒ½å¯å˜çš„å€Ÿç”¨ f è¶…è¿‡ä¸€æ¬¡ã€‚
}
 
fn main() {
    foobar(|x| x * 2);
}
```
å°†ä¸Šé¢çš„ä»£ç ç¨å¾®ä¿®æ”¹ä¸€ä¸‹å°±å¥½äº†ï¼š
```rust
fn foobar<F>(mut f: F)
    where F: FnMut(i32) -> i32
{
    let tmp = f(2);
    println!("{}", f(tmp)); 
}
 
fn main() {
    foobar(|x| x * 2);
}

// è¾“å‡ºï¼š8
```
æŸäº›é—­åŒ…éœ€è¦å¯å˜çš„å€Ÿç”¨æœ¬åœ°å˜é‡ï¼Œå°±éœ€è¦ç”¨åˆ° `FnMut` ç±»å‹ã€‚
```rust
fn foobar<F>(mut f: F)
    where F: FnMut(i32) -> i32
{
    let tmp = f(2);
    println!("{}", f(tmp)); 
}
 
fn main() {
    let mut acc = 2;
    foobar(|x| {
        acc += 1;
        x * acc
    });
}

// è¾“å‡ºï¼š24
```
ä¸èƒ½å°†è¿™ç§é—­åŒ…ä½œä¸º `Fn` ç±»å‹çš„å‚æ•°ï¼š
```rust
fn foobar<F>(f: F)
    where F: Fn(i32) -> i32
{
    println!("{}", f(f(2))); 
}
 
fn main() {
    let mut acc = 2;
    foobar(|x| {
        acc += 1;
        // error: cannot assign to `acc`, as it is a captured variable in a `Fn` closure. the compiler suggests "changing foobar to accept closures that implement `FnMut`"
        // è¯‘ï¼šé”™è¯¯ï¼šåœ¨ Fn ç±»å‹çš„é—­åŒ…ä¸­ï¼Œä¸èƒ½ç»™å˜é‡ acc èµ‹å€¼ã€‚ç¼–è¯‘å™¨å»ºè®®è®© foobar å‡½æ•°å…è®¸æ¥å— FnMut ç±»å‹çš„é—­åŒ…ã€‚
        x * acc
    });
}
```
`FnOnce` ç±»å‹çš„é—­åŒ…åªèƒ½è¢«è°ƒç”¨ä¸€æ¬¡ã€‚æŸäº›é—­åŒ…å°†æœ¬åœ°å˜é‡ç§»åŠ¨åˆ°é—­åŒ…ä¸­ï¼Œè¿è¡Œç»“æŸåå†å°†æœ¬åœ°å˜é‡ç§»åŠ¨åˆ°è°ƒç”¨å‡½æ•°ï¼Œè¿™é€šå¸¸ä¼šä½¿ç”¨åˆ° `FnOnce` ç±»å‹çš„é—­åŒ…ã€‚
```rust
fn foobar<F>(f: F)
    where F: FnOnce() -> String
{
    println!("{}", f()); 
}
 
fn main() {
    let s = String::from("alright");
    foobar(move || s);
    // å˜é‡ s è¢«ç§»åŠ¨åˆ°é—­åŒ…ä¸­ï¼Œé—­åŒ…åˆå°†å˜é‡ s ç§»åŠ¨åˆ°è°ƒç”¨å‡½æ•°ã€‚æ³¨æ„ String ç±»å‹æ²¡æœ‰å®ç° Copy Trait
    // todo
}
```
`FnOnce` é—­åŒ…éœ€è¦è¢«ç§»åŠ¨ã€‚

å› æ­¤ï¼Œä¸‹é¢çš„ä»£ç æ˜¯é”™è¯¯çš„ï¼š
```rust
fn foobar<F>(f: F)
    where F: FnOnce() -> String
{
    println!("{}", f()); 
    println!("{}", f()); 
    // é”™è¯¯ï¼šä½¿ç”¨å·²ç»ç§»åŠ¨çš„å€¼ï¼šf
```
ä½ å¯ä»¥ç”¨ä¸‹é¢çš„ä»£ç æ¥ç¡®å®šé—­åŒ…å·²ç»ç§»åŠ¨äº†å˜é‡ sï¼Œä¸‹é¢çš„ä»£ç æ˜¯é”™è¯¯çš„ï¼š
```rust
fn main() {
    let s = String::from("alright");
    foobar(move || s);
    foobar(move || s);
    // é”™è¯¯ï¼šä½¿ç”¨å·²ç»ç§»åŠ¨çš„å€¼ï¼šs
}
```
ä½†ä¸‹é¢çš„ä»£ç æ˜¯åˆæ³•çš„ï¼š
```rust
fn main() {
    let s = String::from("alright");
    foobar(|| s.clone());
    foobar(|| s.clone());
}
```
ä½¿ç”¨é—­åŒ…ä¼ é€’ä¸¤ä¸ªå‚æ•°ï¼š
```rust
fn foobar<F>(x: i32, y: i32, is_greater: F)
    where F: Fn(i32, i32) -> bool
{
    let (greater, smaller) = if is_greater(x, y) {
        (x, y)
    } else {
        (y, x)
    };
    println!("{} is greater than {}", greater, smaller);
}
 
fn main() {
    foobar(32, 64, |x, y| x > y);
}
```
ä½¿ç”¨é—­åŒ…å¿½ç•¥å‚æ•°ï¼š
```rust
fn main() {
    foobar(32, 64, |_, _| panic!("Comparing is futile!"));
}
```
è¿™æ˜¯ä¸€ä¸ªé—­åŒ…çš„ä½¿ç”¨æ¡ˆä¾‹ï¼š
```rust
fn countdown<F>(count: usize, tick: F)
    where F: Fn(usize)
{
    for i in (1..=count).rev() {
        tick(i);
    }
}
 
fn main() {
    countdown(3, |i| println!("tick {}...", i));
}

// è¾“å‡ºï¼š
// tick 3...
// tick 2...
// tick 1...
```
è¿™æ˜¯ä¸€ä¸ªé©¬æ¡¶é—­åŒ…ï¼š
```rust
fn main() {
    countdown(3, |_| ());
}
```
å› ä¸º `|_|()` çœ‹èµ·æ¥åƒé©¬æ¡¶ã€‚

ä»»ä½•å¯è¿­ä»£çš„å˜é‡éƒ½å¯ä»¥ä½¿ç”¨ `for in` æ¥éå†ï¼Œæˆ‘ä»¬åˆšçœ‹è¿‡äº† `range` çš„éå†ï¼Œäº‹å®ä¸Š `Vec` ä¹Ÿå¯ä»¥ä½¿ç”¨ `for in` éå†ï¼š
```rust
fn main() {
    for i in vec![52, 49, 21] {
        println!("I like the number {}", i);
    }
}
```
æˆ–è€…ä¸€ä¸ªåˆ‡ç‰‡ï¼š
```rust
fn main() {
    for i in &[52, 49, 21] {
        println!("I like the number {}", i);
    }
}

// è¾“å‡ºï¼š
// I like the number 52
// I like the number 49
// I like the number 21
```
æˆ–è€…ä¸€ä¸ªè¿­ä»£å™¨ï¼š
```rust
fn main() {
    // æ³¨æ„ï¼š&str ç±»å‹ä¹Ÿå¯ä»¥ä½¿ç”¨ .bytes() è¿­ä»£å™¨ã€‚Rust çš„ char ç±»å‹å¤§å°ä¸º 4 ä¸ªå­—èŠ‚ï¼Œä»£è¡¨ Unicode æ ‡é‡å€¼ã€‚
    for c in "rust".chars() {
        println!("Give me a {}", c);
    }
}

// è¾“å‡ºï¼š
// Give me a r
// Give me a u
// Give me a s
// Give me a t
```
å³ä½¿å¯è¿­ä»£çš„é¡¹ç›®ä½¿ç”¨ filter è¿‡æ»¤æˆ–æ˜¯ä½¿ç”¨ flatten éå†ï¼Œä¾ç„¶å¯ä»¥ä½¿ç”¨ `for in`ï¼š
```rust
fn main() {
    for c in "SuRPRISE INbOUND"
        .chars()
        .filter(|c| c.is_lowercase())
        .flat_map(|c| c.to_uppercase())
    {
        print!("{}", c);
    }
    println!();
}

// è¾“å‡ºï¼šUB
```
ä½ è¿˜å¯ä»¥ä»å‡½æ•°ä¸­è¿”å›ä¸€ä¸ªé—­åŒ…ï¼š
```rust
fn make_tester(answer: String) -> impl Fn(&str) -> bool {
    move |challenge| {
        challenge == answer
    }
}

fn main() {
    // ä½ å¯ä»¥ä½¿ç”¨ .into()  æ¥å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œè¿™é‡Œå°† &'static str è½¬æ¢ä¸º String ç±»å‹
    let test = make_tester("hunter2".into());
    println!("{}", test("******"));
    println!("{}", test("hunter2"));
}
```
ä½ ç”šè‡³å¯ä»¥ç§»åŠ¨ä¸€ä¸ªå¼•ç”¨æ¥ä½œä¸ºå‡½æ•°çš„å‚æ•°ä½œä¸ºè¿”å›çš„é—­åŒ…çš„ç”Ÿå‘½å‘¨æœŸï¼š
```rust
fn make_tester<'a>(answer: &'a str) -> impl Fn(&str) -> bool + 'a {
    move |challenge| {
        challenge == answer
    }
}

fn main() {
    let test = make_tester("hunter2");
    println!("{}", test("*******"));
    println!("{}", test("hunter2"));
}

// è¾“å‡ºï¼š
// false
// true
```
æˆ–è€…ä½¿ç”¨çœç•¥ç”Ÿå‘½å‘¨æœŸï¼š
```rust
fn make_tester(answer: &str) -> impl Fn(&str) -> bool + '_ {
    move |challenge| {
        challenge == answer
    }
}
```
ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»èŠ±è´¹äº†åŠå°æ—¶æ¥é˜…è¯»ä¸Šé¢çš„ä»£ç ç‰‡æ®µï¼Œä½ åº”è¯¥èƒ½å¤Ÿé˜…è¯»ç½‘ä¸Šå¤§éƒ¨åˆ†çš„ Rust ä»£ç ã€‚

åœ¨ç¼–å†™ Rust ä»£ç æ—¶ï¼ŒRust çš„ç¼–è¯‘å™¨çš„æç¤ºä¼šå¾ˆæœ‰å¸®åŠ©ã€‚æ¯”å¦‚ä¸Šé¢æ•…æ„å†™é”™çš„ä»£ç ï¼Œrustc æ€»æ˜¯ä¼šæä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å’Œæœ‰è§åœ°çš„å»ºè®®ã€‚å¦‚æœç¼–è¯‘å™¨ç¼ºå°‘å¿…è¦çš„æç¤ºï¼Œç¼–è¯‘å™¨å›¢é˜Ÿä¼šç§¯æçš„æ·»åŠ ã€‚

å¦‚éœ€æ›´å¤šçš„ Rust å­¦ä¹ èµ„æ–™ï¼Œä½ å¯ä»¥çœ‹çœ‹ä¸‹é¢è¿™äº›å†…å®¹ï¼š
- [The Rust Book](https://doc.rust-lang.org/book/)
- [Rust By Example](https://doc.rust-lang.org/stable/rust-by-example/)
- [Read Rust](https://readrust.net/)
- [This Week In Rust](https://this-week-in-rust.org/)

æˆ‘å†™äº†å…³äº Rust çš„[åšå®¢](https://fasterthanli.me/tags/rust)å’Œ[æ¨æ–‡](https://twitter.com/fasterthanlime)ï¼Œå¦‚æœä½ å–œæ¬¢è¿™ç¯‡æ–‡ç« ï¼Œæ¬¢è¿ç‚¹èµè½¬å‘ã€‚

Have fun!

> åŸæ–‡é“¾æ¥: https://fasterthanli.me/articles/a-half-hour-to-learn-rust
> 
> ç¿»è¯‘ï¼š[Asura](https://github.com/asur4s)
> 
> é€‰é¢˜ï¼š[Asura](https://github.com/asur4s)
>
> æœ¬æ–‡ç”± [Rustt](https://Rustt.org) ç¿»è¯‘ï¼Œ[StudyRust](https://studyrust.org) è£èª‰æ¨å‡º