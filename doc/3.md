读书笔记

# 1 入门指南

## 1.1 简介

为什么要使用 Rust？

可以让每个人编写可靠且高效的软件，让很多 bug 在编译时就能被消灭。
擅长：
- 运行速度
- 内存安全
- 多处理器

比较 C/C++，类型和内存不安全。
比较 Java/C#，保证内存安全，但性能不行。
Rust：
- 安全
- 无需GC
- 易于维护和调试。

Rust 特别擅长：
- 高性能 Web Service
- WebAssembly
- 命令行工具
- 网络编程
- 嵌入式设备
- 系统编程

Rust 用户：
- Google：Fuschia 的 Rust 代码占用 30%。
- Amazon：基于 Linux 开发的直接可以在裸机、虚拟机上运行容器的操作系统。
- System76：下一代操作系统 Redox。

Rust 优点：
- 性能
- 安全性
- 无所畏惧的并发
Rust 缺点：
- 难学。相对于 C++ 很简单……

注意：
- 学习 Rust 有很多独有概念，最好不要跳跃性的学习。

## 1.2 安装 Rust

更新 rust：rustup update
验证安装：rustc --version

本地文档 rustup doc

开发工具：IntelLij IDEA Rust 插件、VScode-rust

## 1.3 Hello World

fn main(){} ，无参数无返回值。

println! 是一个 Macro（宏）。
rust 的缩进是4个空格，不是 tab。

在Windows中会生成 .pdb 文件，包含调试信息。

Rust 是 ahead-of-time 编译的语言，可以先编译程序，把文件发给别人即可运行，无需安装 Rust。

rustc 只适合简单的 Rust 程序。大型程序应该使用 cargo。

## 1.4 cargo

cargo 是rust 的构建系统和包安装工具。

cargo new --vcs 设置版本控制工具。

cargo.toml 是 cargo 配置格式。
- [pacakge] 标题。
- [dependencies] 依赖项

Rust 中代码库叫做 crate。

如果项目没有使用 cargo，也可转换为使用 cargo。
- 移动源码到 src 下。
- 创建 Cargo.toml

编译运行
- cargo build
  - target/debug
- cargo run：构建并且运行项目。
- cargo check：检查代码，运行效率比 build 快，可以连续反复调用 check 命令。
- cargo build --release：
  - target/release


# 2 猜数游戏

## 2.1 一次猜测

## 2.2 生成神秘数字

可重现的 build
- cargo update
- cargo build

完成 guessing game 代码，在 code 目录。

# 3 数据类型

## 3.1 变量与可变性

- 变量默认不可变。
- 使用mut改变可变性。
- 常量：const
- shadowing：覆盖变量，和mut不同，可以改变变量类型。
  
## 3.2 数据类型


- 标量：代表单个值
  - 整数类型.byte:b'A'。发布情况不会溢出，而是环绕。默认 i32
  - 浮点类型，f64 默认。
  - 布尔类型
  - 字符类型：unicode大小，char 可以放入 emoji

## 3.3 数据类型：复合类型
- 复合类型
  - 元组（Tuple）：解构获取值、点标记法、
  - 数组：数组所有值类型必须相同、Vector 比数组用得多。let a:[i32; 5] 声明数组、不允许越界访问

## 3.4 函数与注释
- 函数
  - 蛇皮命名法 snake case
  - parameter 形参、argument 实参（具体值）
  - Rust 是基于表达式的语言
  - 语句没有返回值，表达式有返回值。
  - 在->符号后声明函数返回值类型。
- 注释
  - //
  - /**/

## 3.5 控制流：if else

与条件相关联的代码块叫做分支（arm）。必须使用bool类型。

当分支过多，可以考虑使用 match。

if语句可以作为表达式。

## 3.6 循环

loop、可以使用break来停止循环。

while 每次都要判断一次条件。

数据通常使用 for 来遍历，while容易出错。在 rust 中用的最多。

range可以生成某个范围内的数据（1..4）=>1, 2, 3。

# 4 所有权

## 4.1 堆内存和栈内存

所有程序在运行时都必须管理他们使用计算机内存的方式。
- Rust使用一个所有权系统来管理，让编译器在编译时检查内存问题。

stack：按值得接收顺序来存储，按相反的顺序将它们移除（LIFO），不需要分配内存，直接挨着放。

heap：需要程序员手动申请内存空间。

heap需要使用更多的消耗。

如果指令在内存中跳转的次数越少，那么速度就越快。

所有权解决的问题：
- 跟踪代码的heap空间
- 最小化heap重复数据
- 清理heap上未使用的数据避免空间不足。

**管理heap数据是所有权存在的原因。**

## 4.1.2 所有权规则

- 每个值都有一个变量，变量是所有者。
- 每个值只能有一个所有者。
- 当所有者超出作用域时，该值应该被删除。

String类型比基础标量数据类型更复杂，基础标量类型存储在栈上面。String类型存储在堆上面。

字符串字面值（"string"），也就是字符串中的值，它们不可变。

- 字符串字面值时被硬编码到最终的执行文件中的。
- String在heap上分配内存来保存编译时未知的文本内容

变量走出作用域，会调用 drop 函数。

多个变量与同一个数据使用一种独特的方式来交互，移动Move。

堆栈的变量如果 copy 给另一个变量，如果浅拷贝，容易出现double free，rust 会让前一个变量失效，避免 double free。这种做法叫做 move。

设计原则：rust 不会自动创建深拷贝。任何自动赋值的操作都是廉价的。

如果想要使用深拷贝，可以使用 clone 方法，比较消耗资源。

在栈上（基础类型）不需要 clone，直接复制即可。

Copy Trait，如果类型实现了 Copy，那么旧的变量在赋值后依然可用，和Drop有冲突。
- 任何简单标量都可以 Copy
- 任何分配内存的类型都不可以 Copy
- 常见的 Copy Trait 类型
  - u32
  - bool
  - char
  - 元组

## 4.1.3 所有权与函数

函数在返回值过程中会发生所有权的移动。

如果让函数使用某个值，但不获得所有权呢？
- 引用（Reference）

## 4.2 引用与借用

使用 & 来创建引用，这种行为叫做借用。

正常情况不可以修改借用的东西。

可以通过mut声明可变引用。
- 只能同时有一个可变引用。
- 至少有一个指针用于写入数据。
- 没有使用任何机制来同步对数据的访问。

可以通过创建多个新的作用域，来创建非同时的多个可变引用。

可变应用限制
- 不可以同时拥有一个可变引用和一个不变引用。
- 允许多个不可变引用

悬空引用（Dangling Reference）
- rust可以保证不会出现悬空引用。

引用的规则：
- 在任何时刻，只能满足下列条件之一：
  - 一个可变引用
  - 任意数量不可变的引用。
- 引用必须一直有效才行。

## 4.3 切片

不持有所有权的数据类型，切片（slice）

提取字符串中第一个单词的index，难以将index和String进行同步，但使用字符串切片就可以很容易实现。

字符串字面值是切片。let s = "hello"，s的类型其实是 &str，指向特定位置的切片。

字符串切片作为参数：
- &str作为参数类型：可以同时接收 String和&str类型。

定义函数时，使用字符串切片（&str）来代替字符串引用（&String），会使得我们的API更加的通用，而不会损失任何功能。

类似memory view

# 5 Struct

在花括号内，需要未所有字段定义名称和类型。

实例化 struct，需要为每个字段定义初始值。

一旦 Struct 的实例可变，实例中所有的字段都可变。

当字段名和字段值对应变量名相同时，可以简化。{email: email}=>{email}

struct 更新语法，如果想要基于当前 struct 示例来创建一个新的示例时，可以使用 struct 更新语法。

Tuple Struct，可以定义类似 tuple 的 struct。struct Color(i32, i32, i32);

空结构体（Unit-Like Struct），用途：在某个类型里实现某个 trait，但又不想存储数据。

struct 里面也可以存放引用，但这需要使用生命周期，生命周期保证只要struct示例有效，那么里面的引用也是有效的。

struct 里面的类型大部分时候使用 String，如果使用引用就需要设置生命周期。

## 5.2 struct例子

{:?} 输出结构体，{:#?} 输出美化后的结构体，需要对 struct 实现 debug，#[derive(debug)]

## 5.3 struct 方法

如何把方法和结构体关联呢？

impl StructName{

}

方法的参数，可以使用 &self，或者self，和其他参数一样。

方法调用的运算符，没有->运算符，但rust会自动引用或解引用。
- p1.distance(&p2)
- (&p1).distance(&p2)

上两个相等。

关联函数，不以self作为第一个参数。例如：String::from。类似于 Static 关键字。

（一个 struct 可以有多个 impl 块）

# 6 枚举与模式匹配

## 6.1 定义枚举




参考教程：
- [Rust编程语言入门教程（Rust语言/Rust权威指南配套）](https://www.bilibili.com/video/BV1hp4y1k7SV)
- [Rust 程序设计语言 简体中文版](https://rust.bootcss.com/ch00-00-introduction.html)