主要是想用这本书入门异步、协程。


编程进阶：
- 异步
- 多线程

# 14 可迭代的对象、迭代器和生成器

所有的生成器都是迭代器，因为生成器完全实现了迭代器的接口。不过，根据《设计模式：可复用面向对象软件的基础》一书的定义，**迭代器用于从集合中取出元素；而生成器用于“凭空”生成元素**。
> 通过斐波那契数列能很好的说明二者之间的区别：斐波那契数列中的数有无穷个，在一个集合里放不下。不过，在 Python 社区中，大多数时候都把迭代器和生成器视作同一概念。

# 16 协程

协程的底层架构在 Python 2.5（2006 年）实现。自此之后，yield 关键字可以在表达式中使用，而生成器 API 中增加了 `.send(value)` 方法，发送的数据会成为生成器函数中 yield 表达式的值。
> TODO：没看懂

协程是指一个过程，这个过程与调用方协作，产出由调用方提供的指。
> TODO：没看懂，翻译问题吗？

协程最近的演进来自 Python 3.3，PEP 380 对生成器函数的句法做了两处改动，以便更好的作为协程使用。

新引入了 yield from 句法，使用它可以把复杂的生成器重构成小型嵌套生成器，省去了之前生成器的工作委托给子生成器所需的大量样板代码。

```python
def simple_coroutine():
    print("-> coroutine started")
    x = yield
    print("-> coroutine received:", x)


# 调用函数得到生成器对象
my_coro = simple_coroutine()
# <generator object simple_coroutine at 0x7fc0213ecba0>

# 生成器还没启动， 没在 yield 语句处暂停，所以一开始无法发送数据
print(next(my_coro))
# -> coroutine started
# None

# 调用 send 方法后，协程中的 yield 表达式会计算出 42，并且恢复运行，知道运行到下一个 yield 表达式或者终止
my_coro.send(42)
# -> coroutine received: 42

# 控制权流动到协程定义体的末尾，导致生成器像往常一样抛出 StopIteration 异常。
```

协程处于四个状态中的一个。当前状态可以使用 `inspect.getgeneratorstate(..)` 函数确定，该函数会返回下述字符串中的一个。
- GEN_CREATE：等待开始执行
- GEN_RUNNING：解释器正在执行
- GEN_SUSPENDED：在 yield 表达式出暂停
- GEN_CLOSEED：执行结束

其中 send 方法的参数会暂时成为暂停的 yield 表达式的值，所以，当协程处于暂停状态时才能调用 send 方法，例如 my_coro.send(42)，不过，如果协程还没有激活（即，状态时 GEN_CREATE），情况就不同了。因此，始终要调用 next(my_coro) 激活协程——也可以调用 my_coro.send(None)，效果一样。
> 调用 next(my_coro) 函数这一步通常称为预激协程（即，让协程向前执行到第一个 yield 表达式，准备好作为活跃的协程使用）


