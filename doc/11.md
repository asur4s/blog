主要是想用这本书入门异步、协程。


编程进阶：
- 异步
- 多线程

# 14 可迭代的对象、迭代器和生成器

所有的生成器都是迭代器，因为生成器完全实现了迭代器的接口。不过，根据《设计模式：可复用面向对象软件的基础》一书的定义，**迭代器用于从集合中取出元素；而生成器用于“凭空”生成元素**。
> 通过斐波那契数列能很好的说明二者之间的区别：斐波那契数列中的数有无穷个，在一个集合里放不下。不过，在 Python 社区中，大多数时候都把迭代器和生成器视作同一概念。

# 16 协程

协程的底层架构在 Python 2.5（2006 年）实现。自此之后，yield 关键字可以在表达式中使用，而生成器 API 中增加了 `.send(value)` 方法，发送的数据会成为生成器函数中 yield 表达式的值。
> TODO：没看懂

协程是指一个过程，这个过程与调用方协作，产出由调用方提供的指。
> TODO：没看懂，翻译问题吗？

协程最近的演进来自 Python 3.3，PEP 380 对生成器函数的句法做了两处改动，以便更好的作为协程使用。

新引入了 yield from 句法，使用它可以把复杂的生成器重构成小型嵌套生成器，省去了之前生成器的工作委托给子生成器所需的大量样板代码。

```python
def simple_coroutine():
    print("-> coroutine started")
    x = yield
    print("-> coroutine received:", x)


# 调用函数得到生成器对象
my_coro = simple_coroutine()
# <generator object simple_coroutine at 0x7fc0213ecba0>

# 生成器还没启动， 没在 yield 语句处暂停，所以一开始无法发送数据
print(next(my_coro))
# -> coroutine started
# None

# 调用 send 方法后，协程中的 yield 表达式会计算出 42，并且恢复运行，知道运行到下一个 yield 表达式或者终止
my_coro.send(42)
# -> coroutine received: 42

# 控制权流动到协程定义体的末尾，导致生成器像往常一样抛出 StopIteration 异常。
```

协程处于四个状态中的一个。当前状态可以使用 `inspect.getgeneratorstate(..)` 函数确定，该函数会返回下述字符串中的一个。
- `GEN_CREATE`：等待开始执行
- `GEN_RUNNING`：解释器正在执行
- `GEN_SUSPENDED`：在 yield 表达式出暂停
- `GEN_CLOSEED`：执行结束

其中 send 方法的参数会暂时成为暂停的 yield 表达式的值，所以，当协程处于暂停状态时才能调用 send 方法，例如 my_coro.send(42)，不过，如果协程还没有激活（即，状态时 GEN_CREATE），情况就不同了。因此，始终要调用 next(my_coro) 激活协程——也可以调用 my_coro.send(None)，效果一样。
> 调用 next(my_coro) 函数这一步通常称为预激协程（即，让协程向前执行到第一个 yield 表达式，准备好作为活跃的协程使用）

## 1、为什么协程是趋势？

参考文章：
- https://www.zhihu.com/question/32218874
- https://blog.youxu.info/2014/12/04/coroutine/
- https://github.com/antgod/blog/blob/master/%E6%96%87%E7%AB%A0/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/%E5%91%BD%E4%BB%A4%E5%BC%8F%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%81%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B9%8B%E5%8D%8E%E5%B1%B1%E8%AE%BA%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89.md

协程主要是用来**替代回调**。有以下好处：
1. 用异常来表示调用出错，确保了错误正常处理，又复用了语言里完善的异常处理机制。回调一般需要指定 sucess 和 fail 两个回调函数，大大增加了正确处理的难度，而指定全局 handler 之类的方法在要求不太高的 Web 前端还堪用，在后端就脆弱不堪了。
2. 更方便管理上下文。回调方式严重依赖闭包特性，而要在一个连续逻辑中写出多个回调函数且共享相同的上下文，这样的代码难读懂，难写对，难维护。协程就简单多了。还可以使用循环、上下文管理器等语法特性。
3. 更方便处理并发逻辑。例如，要同时建立多个 TCP 连接，然后在第一个成功之后取消其他的，用简单的回调接口是非常困难的，用 promise 的回调也需要一定的技巧，用协程框架就简单清晰多了。

对学习懒惰而对重复自己勤奋，这时程序员的大忌。
> 吾尝终日而思矣，不如须臾之所学也。

---

最早提出“协程”概念的 Melvin Conway 的出发点是**如何写出一个只扫描一遍程序（one-pass）的 COBOL 编译器**。

协程作为一个比子进程更加通用的概念，在实际编程却没有取代子进程，这一点是出乎意外的。如果我们结合当时的程序设计思想看，这一点又是意料之中的：**协程是不符合那个时代所崇尚的“自定向下”的程序设计思想的**，自然也就不会称为当时主流的命令式编成语言的一部分。

正如面向对象的语言是围绕面向对象的开发理念设计一样，命令式编程语言是围绕自顶向下的理念设计的。在自顶向下的理念指导下，程序被切分为主程序和大大小小的子模块，每个子模块又可能调用更多子模块等等。**具有执行中让出和恢复功能的协程在这种结构下无用武之地**。可以说，自上而下的设计思想从一开始就排除了对协程的需求，其后的结构化编程（Structural Programming）思想，更是强化了“子进程调用作为唯一控制结构”的基本假设。在这样的指导思想下，协程一直没有称为当时编成语言的一等公民。

实践中，协程的思想频繁应用于任务调度和流处理上。比如，UNIX 管道就可以看成是众多命令间的协同操作。当然，管道的现代实现都是以 `pipe()` 系统调用和进程间的通信为基础，而非简单遵循协程的 yield 语法。

许多协同式多任务操作系统，也可以堪称协程运行系统。

---

**协程的复兴**

编程思想是否能普及开来，很大程度在于应用场景。协程没有能在自顶向下的世界里立足，却在动态语言世界里大放光彩，这里最显著的例子莫过于 Python 中的迭代器和生成器。

**协程思想本质上就是控制流的主动让出和恢复机制**。在现代语言里，可以实现协程思想的方法很多，这些实现间并无高低之分，所区别就是是否适合应用场景。
> 半对称协程与对称协程、有栈与无栈协程。


---

**协程的应用：消费者和生成者设计模式**


---



## 2、指令式编程（Imperative programming）、声明式编程（Declarative Programming）是什么？

参考文章：
- https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B
- https://github.com/antgod/blog/blob/master/%E6%96%87%E7%AB%A0/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/%E5%91%BD%E4%BB%A4%E5%BC%8F%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%81%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B9%8B%E5%8D%8E%E5%B1%B1%E8%AE%BA%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89.md

编程范型、编程范式或程序设计法（Programming paradigm），是指软件工程中一类典型的编程风格。常见的编程泛型有：函数式编程、面向对象编程、指令式编程（命令式编程）、声明式编程。

**指令式编程**：告诉机器如何做事情，不管你想做的是什么，他都会按照你的命令实现。汇编指令都是命令式的。
```js
var numbers = [1,2,3,4,5]
var doubled = []
for(var i = 0; i < numbers.length; i++) {
  var newNumber = numbers[i] * 2
  doubled.push (newNumber)
}
console.log (doubled) //=> [2,4,6,8,10]
```

**声明式编程**：告诉机器你想要的是什么，让机器想出如何去做。
```js
var numbers = [1,2,3,4,5]
var doubled = numbers.map (function (n) {
  return n * 2
})
console.log (doubled) //=> [2,4,6,8,10]
```
声明式的编程，不仅可读性更高，也更加简洁。最重要的是：我们描述了我们想要做什么，而不是我们如何去做的细节。

如果我们花时间去学习声明式可以归纳抽离的部分，它们能为我们的编程带来巨大的遍历。首先，我们可以少写代码，这就是通往成功的捷径。其次，我们可以抽象出非常实用的工具类，对对象或者函数进行深度加工、嵌套、运算，直到得到想要的结果。最后，每当需求变更时候，大多数情况下，我们无需改写框架代码，只需要修改声明式的配置即可完成需求变更。

**最重要的是，他们能让我们站在更高的层次思考**。站在云端思考我们想要的是什么，什么是变化的，什么是不变的，找到变化，配置之，找到不变，封装之。最后你会发现，我们不关心变化，因为变化的通过配置来声明，我们只关心不变，也就是框架，用框架（不变）来处理声明（变化）。**正如道家的哲学，以不变（框架）应万变（声明）**。而不是站在底层，思考事情该如何去做。


---

面向对象语言是指令式编程的一种抽象。抽象包括两方面，数据抽象和过程抽象。

但是绝大多数的面向对象编程，不会根据声明配置去生成逻辑，逻辑的调用是封装在对象中，而不是动态生成。所以没有做到真正的声明式，也就是数据与逻辑完全分离。这里说的动态生成逻辑，是根据声明，自动完成逻辑的生成，这样就完全可以不用编写业务代码，而仅仅靠声明来完成逻辑的实现，而这一部分处理，交给框架处理即可。

函数式编程把逻辑完全视为函数的计算。把数据的逻辑封装到函数中，通过对函数的计算、加工、处理来生成新的函数，最后拼装成一个个功能独立的函数。再运用这些函数，完成复杂的逻辑实现。

## 3、控制反转、依赖注入、依赖倒置是什么？


## 4、面向对象设计原则

参考文章：
- https://zhuanlan.zhihu.com/p/58092071

## 5、函数式编程设计原则

参考文章：
- https://softwareengineeringdaily.com/2018/12/12/the-design-of-functional-programs/


## GoF设计模式

